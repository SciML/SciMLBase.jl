<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SciMLProblems · SciMLBase.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://scimlbase.sciml.ai/stable/interfaces/Problems/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SciMLBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SciMLBase.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Interfaces</span><ul><li class="is-active"><a class="tocitem" href>SciMLProblems</a><ul class="internal"><li><a class="tocitem" href="#Definition-of-the-SciMLProblem-Interface"><span>Definition of the SciMLProblem Interface</span></a></li><li><a class="tocitem" href="#Problem-Traits"><span>Problem Traits</span></a></li><li><a class="tocitem" href="#SciMLProblem-API"><span>SciMLProblem API</span></a></li></ul></li><li><a class="tocitem" href="../SciMLFunctions/">SciMLFunctions (Jacobians, Sparsity, Etc.)</a></li><li><a class="tocitem" href="../Algorithms/">SciMLAlgorithms</a></li><li><a class="tocitem" href="../Solutions/">SciMLSolutions</a></li><li><a class="tocitem" href="../Init_Solve/">The SciML init and solve Functions</a></li><li><a class="tocitem" href="../Common_Keywords/">Common Keyword Arguments</a></li><li><a class="tocitem" href="../Differentiation/">Automatic Differentiation and Sensitivity Algorithms (Adjoints)</a></li><li><a class="tocitem" href="../PDE/">The PDE Definition Interface</a></li></ul></li><li><span class="tocitem">Fundamentals</span><ul><li><a class="tocitem" href="../../fundamentals/FAQ/">Frequently Asked Questions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Interfaces</a></li><li class="is-active"><a href>SciMLProblems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SciMLProblems</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLBase.jl/blob/master/docs/src/interfaces/Problems.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SciMLProblems"><a class="docs-heading-anchor" href="#SciMLProblems">SciMLProblems</a><a id="SciMLProblems-1"></a><a class="docs-heading-anchor-permalink" href="#SciMLProblems" title="Permalink"></a></h1><p>The cornerstone of the SciML common interface is the problem type definition. These definitions are the encoding of mathematical problems into a numerically computable form. </p><h3 id="Note-About-Symbolics-and-ModelingToolkit"><a class="docs-heading-anchor" href="#Note-About-Symbolics-and-ModelingToolkit">Note About Symbolics and ModelingToolkit</a><a id="Note-About-Symbolics-and-ModelingToolkit-1"></a><a class="docs-heading-anchor-permalink" href="#Note-About-Symbolics-and-ModelingToolkit" title="Permalink"></a></h3><p>The symbolic analog to the problem interface is the ModelingToolkit <code>AbstractSystem</code>. For example, <code>ODESystem</code> is the symbolic analog to <code>ODEProblem</code>. Each of these system types have a method for constructing the associated problem and function types.</p><h2 id="Definition-of-the-SciMLProblem-Interface"><a class="docs-heading-anchor" href="#Definition-of-the-SciMLProblem-Interface">Definition of the SciMLProblem Interface</a><a id="Definition-of-the-SciMLProblem-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-SciMLProblem-Interface" title="Permalink"></a></h2><p>The following standard principles should be adhered to across all  <code>SciMLProblem</code> instantiations.</p><h3 id="In-place-Specification"><a class="docs-heading-anchor" href="#In-place-Specification">In-place Specification</a><a id="In-place-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#In-place-Specification" title="Permalink"></a></h3><p>Each <code>SciMLProblem</code> type can be called with an &quot;is inplace&quot; (iip) choice. For example:</p><pre><code class="language-julia hljs">ODEProblem(f,u0,tspan,p)
ODEProblem{iip}(f,u0,tspan,p)</code></pre><p>which is a boolean for whether the function is in the inplace form (mutating to change the first value). This is automatically determined using the methods table but note that for full type-inferrability of the <code>SciMLProblem</code> this iip-ness should be specified.</p><p>Additionally, the functions are fully specialized to reduce the runtimes. If one would instead like to not specialize on the functions to reduce compile time, then one can set <code>recompile</code> to false.</p><h3 id="Default-Parameters"><a class="docs-heading-anchor" href="#Default-Parameters">Default Parameters</a><a id="Default-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Default-Parameters" title="Permalink"></a></h3><p>By default, <code>SciMLProblem</code> types use the <code>SciMLBase.NullParameters()</code> singleton to define the absence of parameters by default. The reason is because this throws an informative error if the parameter is used or accessed within the user&#39;s function, for example, <code>p[1]</code> will throw an informative error about forgetting to pass parameters.</p><h3 id="Keyword-Argument-Splatting"><a class="docs-heading-anchor" href="#Keyword-Argument-Splatting">Keyword Argument Splatting</a><a id="Keyword-Argument-Splatting-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-Argument-Splatting" title="Permalink"></a></h3><p>All <code>SciMLProblem</code> types allow for passing keyword arguments that would get forwarded to the solver. The reason for this is that in many cases, like in <code>EnsembleProblem</code> usage, a <code>SciMLProblem</code> might be associated with some solver configuration, such as a callback or tolerance. Thus, for flexibility the extra keyword arguments to the <code>SciMLProblem</code> are carried to the solver.</p><h3 id="problem_type"><a class="docs-heading-anchor" href="#problem_type">problem_type</a><a id="problem_type-1"></a><a class="docs-heading-anchor-permalink" href="#problem_type" title="Permalink"></a></h3><p><code>SciMLProblem</code> types include a non-public API definition of <code>problem_type</code> which holds a trait type corresponding to the way the <code>SciMLProblem</code> was constructed. For example, if a <code>SecondOrderODEProblem</code> constructor is used, the returned problem is simply a <code>ODEProblem</code> for interopability with any <code>ODEProblem</code> algorithm. However, in this case the <code>problem_type</code> will be populated with the <code>SecondOrderODEProblem</code> type, indicating the original definition and extra structure.</p><h3 id="Remake"><a class="docs-heading-anchor" href="#Remake">Remake</a><a id="Remake-1"></a><a class="docs-heading-anchor-permalink" href="#Remake" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.remake" href="#SciMLBase.remake"><code>SciMLBase.remake</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remake(thing; &lt;keyword arguments&gt;)</code></pre><p>Re-construct <code>thing</code> with new field values specified by the keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/remake.jl#L20-L25">source</a></section></article><h2 id="Problem-Traits"><a class="docs-heading-anchor" href="#Problem-Traits">Problem Traits</a><a id="Problem-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Traits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.isinplace-Tuple{SciMLBase.DEProblem}" href="#SciMLBase.isinplace-Tuple{SciMLBase.DEProblem}"><code>SciMLBase.isinplace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinplace(prob::SciMLProblem)</code></pre><p>Determine whether the function of the given problem operates in place or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/problem_traits.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.is_diagonal_noise" href="#SciMLBase.is_diagonal_noise"><code>SciMLBase.is_diagonal_noise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_diagonal_noise(prob::SciMLProblem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/problem_traits.jl#L1-L3">source</a></section></article><h2 id="SciMLProblem-API"><a class="docs-heading-anchor" href="#SciMLProblem-API">SciMLProblem API</a><a id="SciMLProblem-API-1"></a><a class="docs-heading-anchor-permalink" href="#SciMLProblem-API" title="Permalink"></a></h2><h3 id="Abstract-SciMLProblems"><a class="docs-heading-anchor" href="#Abstract-SciMLProblems">Abstract SciMLProblems</a><a id="Abstract-SciMLProblems-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-SciMLProblems" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SciMLProblem" href="#SciMLBase.SciMLProblem"><code>SciMLBase.SciMLProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type SciMLProblem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DEProblem" href="#SciMLBase.DEProblem"><code>SciMLBase.DEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type DEProblem &lt;: SciMLBase.SciMLProblem</code></pre><p>Base type for all DifferentialEquations.jl problems. Concrete subtypes of <code>DEProblem</code> contain the necessary information to fully define a differential equation of the corresponding type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractLinearProblem" href="#SciMLBase.AbstractLinearProblem"><code>SciMLBase.AbstractLinearProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLinearProblem{bType, isinplace} &lt;: SciMLBase.SciMLProblem</code></pre><p>Base for types which define linear systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractNonlinearProblem" href="#SciMLBase.AbstractNonlinearProblem"><code>SciMLBase.AbstractNonlinearProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractNonlinearProblem{uType, isinplace} &lt;: SciMLBase.DEProblem</code></pre><p>Base for types which define nonlinear solve problems (f(u)=0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L65">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SciMLBase.AbstractQuadratureProblem</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractOptimizationProblem" href="#SciMLBase.AbstractOptimizationProblem"><code>SciMLBase.AbstractOptimizationProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractOptimizationProblem{isinplace} &lt;: SciMLBase.SciMLProblem</code></pre><p>Base for types which define equations for optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractNoiseProblem" href="#SciMLBase.AbstractNoiseProblem"><code>SciMLBase.AbstractNoiseProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractNoiseProblem &lt;: SciMLBase.DEProblem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractODEProblem" href="#SciMLBase.AbstractODEProblem"><code>SciMLBase.AbstractODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractODEProblem{uType, tType, isinplace} &lt;: SciMLBase.DEProblem</code></pre><p>Base for types which define ODE problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractDiscreteProblem" href="#SciMLBase.AbstractDiscreteProblem"><code>SciMLBase.AbstractDiscreteProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDiscreteProblem{uType, tType, isinplace} &lt;: SciMLBase.AbstractODEProblem{uType, tType, isinplace}</code></pre><p>Base for types which define discrete problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractAnalyticalProblem" href="#SciMLBase.AbstractAnalyticalProblem"><code>SciMLBase.AbstractAnalyticalProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractAnalyticalProblem{uType, tType, isinplace} &lt;: SciMLBase.AbstractODEProblem{uType, tType, isinplace}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractRODEProblem" href="#SciMLBase.AbstractRODEProblem"><code>SciMLBase.AbstractRODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractRODEProblem{uType, tType, isinplace, ND} &lt;: SciMLBase.DEProblem</code></pre><p>Base for types which define RODE problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractSDEProblem" href="#SciMLBase.AbstractSDEProblem"><code>SciMLBase.AbstractSDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSDEProblem{uType, tType, isinplace, ND} &lt;: SciMLBase.AbstractRODEProblem{uType, tType, isinplace, ND}</code></pre><p>Base for types which define SDE problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractDAEProblem" href="#SciMLBase.AbstractDAEProblem"><code>SciMLBase.AbstractDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDAEProblem{uType, duType, tType, isinplace} &lt;: SciMLBase.DEProblem</code></pre><p>Base for types which define DAE problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractDDEProblem" href="#SciMLBase.AbstractDDEProblem"><code>SciMLBase.AbstractDDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDDEProblem{uType, tType, lType, isinplace} &lt;: SciMLBase.DEProblem</code></pre><p>Base for types which define DDE problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractConstantLagDDEProblem" href="#SciMLBase.AbstractConstantLagDDEProblem"><code>SciMLBase.AbstractConstantLagDDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractConstantLagDDEProblem{uType, tType, lType, isinplace} &lt;: SciMLBase.AbstractDDEProblem{uType, tType, lType, isinplace}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractSecondOrderODEProblem" href="#SciMLBase.AbstractSecondOrderODEProblem"><code>SciMLBase.AbstractSecondOrderODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSecondOrderODEProblem{uType, tType, isinplace} &lt;: SciMLBase.AbstractODEProblem{uType, tType, isinplace}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractBVProblem" href="#SciMLBase.AbstractBVProblem"><code>SciMLBase.AbstractBVProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractBVProblem{uType, tType, isinplace} &lt;: SciMLBase.AbstractODEProblem{uType, tType, isinplace}</code></pre><p>Base for types which define BVP problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractJumpProblem" href="#SciMLBase.AbstractJumpProblem"><code>SciMLBase.AbstractJumpProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractJumpProblem{P, J} &lt;: SciMLBase.DEProblem</code></pre><p>Base for types which define jump problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractSDDEProblem" href="#SciMLBase.AbstractSDDEProblem"><code>SciMLBase.AbstractSDDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSDDEProblem{uType, tType, lType, isinplace, ND} &lt;: SciMLBase.DEProblem</code></pre><p>Base for types which define SDDE problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractConstantLagSDDEProblem" href="#SciMLBase.AbstractConstantLagSDDEProblem"><code>SciMLBase.AbstractConstantLagSDDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractConstantLagSDDEProblem{uType, tType, lType, isinplace, ND} &lt;: SciMLBase.AbstractSDDEProblem{uType, tType, lType, isinplace, ND}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractPDEProblem" href="#SciMLBase.AbstractPDEProblem"><code>SciMLBase.AbstractPDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractPDEProblem &lt;: SciMLBase.DEProblem</code></pre><p>Base for types which define PDE problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/SciMLBase.jl#L166">source</a></section></article><h3 id="Concrete-SciMLProblems"><a class="docs-heading-anchor" href="#Concrete-SciMLProblems">Concrete SciMLProblems</a><a id="Concrete-SciMLProblems-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-SciMLProblems" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.LinearProblem" href="#SciMLBase.LinearProblem"><code>SciMLBase.LinearProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a linear system problem. Documentation Page: http://linearsolve.sciml.ai/dev/basics/LinearProblem/</p><p><strong>Mathematical Specification of a Linear Problem</strong></p><p><strong>Concrete LinearProblem</strong></p><p>To define a <code>LinearProblem</code>, you simply need to give the <code>AbstractMatrix</code> <span>$A$</span> and an <code>AbstractVector</code> <span>$b$</span> which defines the linear system:</p><p class="math-container">\[Au = b\]</p><p><strong>Matrix-Free LinearProblem</strong></p><p>For matrix-free versions, the specification of the problem is given by an operator <code>A(u,p,t)</code> which computes <code>A*u</code>, or in-place as <code>A(du,u,p,t)</code>. These are specified via the <code>AbstractSciMLOperator</code> interface. For more details, see the <a href="https://scimlbase.sciml.ai/dev/">SciMLBase Documentation</a>.</p><p>Note that matrix-free versions of LinearProblem definitions are not compatible with all solvers. To check a solver for compatibility, use the function xxxxx.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><p>Optionally, an initial guess <span>$u₀$</span> can be supplied which is used for iterative methods.</p><pre><code class="language-julia hljs">LinearProblem{isinplace}(A,x,p=NullParameters();u0=nothing,kwargs...)
LinearProblem(f::AbstractDiffEqOperator,u0,p=NullParameters();u0=nothing,kwargs...)</code></pre><p><code>isinplace</code> optionally sets whether the function is in-place or not, i.e. whether the solvers are allowed to mutate. By default this is true for <code>AbstractMatrix</code>, and for <code>AbstractSciMLOperator</code>s it matches the choice of the operator definition.</p><p>Parameters are optional, and if not given, then a <code>NullParameters()</code> singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers.</p><p><strong>Fields</strong></p><ul><li><code>A</code>: The representation of the linear operator.</li><li><code>b</code>: The right-hand side of the linear system.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code>. Currently unused.</li><li><code>u0</code>: The initial condition used by iterative solvers.</li><li><code>kwargs</code>: The keyword arguments passed on to the solvers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/basic_problems.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.NonlinearProblem" href="#SciMLBase.NonlinearProblem"><code>SciMLBase.NonlinearProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a nonlinear system problem. Documentation Page: https://nonlinearsolve.sciml.ai/dev/basics/NonlinearProblem/</p><p><strong>Mathematical Specification of a Nonlinear Problem</strong></p><p>To define a Nonlinear Problem, you simply need to give the function <span>$f$</span> which defines the nonlinear system:</p><p class="math-container">\[f(u,p) = 0\]</p><p>and an initial guess <span>$u₀$</span> of where <code>f(u,p)=0</code>. <code>f</code> should be specified as <code>f(u,p)</code> (or in-place as <code>f(du,u,p)</code>), and <code>u₀</code> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher-dimension tensors as well.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">NonlinearProblem(f::NonlinearFunction,u0,p=NullParameters();kwargs...)
NonlinearProblem{isinplace}(f,u0,p=NullParameters();kwargs...)</code></pre><p><code>isinplace</code> optionally sets whether the function is in-place or not. This is determined automatically, but not inferred.</p><p>Parameters are optional, and if not given, then a <code>NullParameters()</code> singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>For specifying Jacobians and mass matrices, see the <a href="interfaces/@ref nonlinearfunctions">NonlinearFunctions</a> page.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function in the problem.</li><li><code>u0</code>: The initial guess for the steady state.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code>.</li><li><code>kwargs</code>: The keyword arguments passed on to the solvers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/basic_problems.jl#L79">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>QuadratureProblem</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.OptimizationProblem" href="#SciMLBase.OptimizationProblem"><code>SciMLBase.OptimizationProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a optimization problem. Documentation Page: https://galacticoptim.sciml.ai/dev/API/optimization_problem/</p><p><strong>Mathematical Specification of a Optimization Problem</strong></p><p>To define an Optimization Problem, you simply need to give the function <span>$f$</span> which defines the cost function to minimize:</p><p class="math-container">\[min_u f(u,p) = 0\]</p><p><span>$u₀$</span> is an initial guess of the minimum. <code>f</code> should be specified as <code>f(u,p)</code> and <code>u₀</code> should be an AbstractArray (or number) whose geometry matches the  desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors  for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices /  higher-dimension tensors as well.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">OptimizationProblem{iip}(f, x, p = SciMLBase.NullParameters(),;
                        lb = nothing,
                        ub = nothing,
                        lcons = nothing,
                        ucons = nothing,
                        sense = nothing,
                        kwargs...)</code></pre><p><code>isinplace</code> optionally sets whether the function is in-place or not. This is determined automatically, but not inferred. Note that for OptimizationProblem, in-place only refers to the Jacobian and Hessian functions, and thus by default if the <code>OptimizationFunction</code> is not defined directly then <code>iip = true</code> is done by default.</p><p>Parameters are optional, and if not given, then a <code>NullParameters()</code> singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p><code>lb</code> and <code>ub</code> are the upper and lower bounds for box constraints on the optimization. They should be an <code>AbstractArray</code> matching the geometry of <code>u</code>, where <code>(lb[I],ub[I])</code> is the box constraint (lower and upper bounds) for <code>u[I]</code>.</p><p><code>lcons</code> and <code>ucons</code> are the upper and lower bounds for equality constraints on the optimization. They should be an <code>AbstractArray</code> matching the geometry of <code>u</code>, where <code>(lcons[I],ucons[I])</code> is the constraint (lower and upper bounds) for <code>cons[I]</code>.</p><p>If <code>f</code> is a standard Julia function, it is automatically converted into an <code>OptimizationFunction</code> with <code>NoAD()</code>, i.e., no automatic generation of the derivative functions.</p><p>Any extra keyword arguments are captured to be sent to the optimizers.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function in the problem.</li><li><code>u0</code>: The initial guess for the optima.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code>.</li><li><code>lb</code>: the lower bounds for the optimization of <code>u</code>.</li><li><code>ub</code>: the upper bounds for the optimization of <code>u</code>.</li><li><code>lcons</code>:</li><li><code>ucons</code>:</li><li><code>sense</code>:</li><li><code>kwargs</code>: The keyword arguments passed on to the solvers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/basic_problems.jl#L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.BVProblem" href="#SciMLBase.BVProblem"><code>SciMLBase.BVProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines an BVP problem. Documentation Page: https://diffeq.sciml.ai/stable/types/bvp_types/</p><p><strong>Mathematical Specification of a BVP Problem</strong></p><p>To define a BVP Problem, you simply need to give the function <span>$f$</span> and the initial condition <span>$u_0$</span> which define an ODE:</p><p class="math-container">\[\frac{du}{dt} = f(u,p,t)\]</p><p>along with an implicit function <code>bc!</code> which defines the residual equation, where</p><p class="math-container">\[bc(u,p,t) = 0\]</p><p>is the manifold on which the solution must live. A common form for this is the two-point <code>BVProblem</code> where the manifold defines the solution at two points:</p><p class="math-container">\[u(t_0) = a
u(t_f) = b\]</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">TwoPointBVProblem{isinplace}(f,bc!,u0,tspan,p=NullParameters();kwargs...)
BVProblem{isinplace}(f,bc!,u0,tspan,p=NullParameters();kwargs...)</code></pre><p>For any BVP problem type, <code>bc!</code> is the inplace function:</p><pre><code class="language-julia hljs">bc!(residual, u, p, t)</code></pre><p>where <code>residual</code> computed from the current <code>u</code>. <code>u</code> is an array of solution values where <code>u[i]</code> is at time <code>t[i]</code>, while <code>p</code> are the parameters. For a <code>TwoPointBVProblem</code>, <code>t = tspan</code>. For the more general <code>BVProblem</code>, <code>u</code> can be all of the internal time points, and for shooting type methods <code>u=sol</code> the ODE solution. Note that all features of the <code>ODESolution</code> are present in this form. In both cases, the size of the residual matches the size of the initial condition.</p><p>Parameters are optional, and if not given then a <code>NullParameters()</code> singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function for the ODE.</li><li><code>bc</code>: The boundary condition function.</li><li><code>u0</code>: The initial condition. Either the initial condition for the ODE as an initial value problem, or a <code>Vector</code> of values for <span>$u(t_i)$</span> for collocation methods</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code></li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/bvp_problems.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DAEProblem" href="#SciMLBase.DAEProblem"><code>SciMLBase.DAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines an implicit ordinary differential equation (ODE) or  differential-algebraic equation (DAE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/dae_types/</p><p><strong>Mathematical Specification of an DAE Problem</strong></p><p>To define a DAE Problem, you simply need to give the function <span>$f$</span> and the initial condition <span>$u_0$</span> which define an ODE:</p><p class="math-container">\[0 = f(du,u,p,t)\]</p><p><code>f</code> should be specified as <code>f(du,u,p,t)</code> (or in-place as <code>f(resid,du,u,p,t)</code>). Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher dimension tensors as well.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><ul><li><code>DAEProblem(f::DAEFunction,du0,u0,tspan,p=NullParameters();kwargs...)</code></li><li><code>DAEProblem{isinplace}(f,du0,u0,tspan,p=NullParameters();kwargs...)</code> : Defines the DAE with the specified functions. <code>isinplace</code> optionally sets whether the function is inplace or not. This is determined automatically, but not inferred.</li></ul><p>Parameters are optional, and if not given then a <code>NullParameters()</code> singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>For specifying Jacobians and mass matrices, see the <a href="interfaces/@ref performance_overloads">DiffEqFunctions</a> page.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function in the ODE.</li><li><code>du0</code>: The initial condition for the derivative.</li><li><code>u0</code>: The initial condition.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>differential_vars</code>: A logical array which declares which variables are the differential (non algebraic) vars (i.e. <code>du&#39;</code> is in the equations for this variable). Defaults to nothing. Some solvers may require this be set if an initial condition needs to be determined.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code></li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul><p><strong>Example Problems</strong></p><p>Examples problems can be found in <a href="https://github.com/JuliaDiffEq/DiffEqProblemLibrary.jl/blob/master/src/dae_premade_problems.jl">DiffEqProblemLibrary.jl</a>.</p><p>To use a sample problem, such as <code>prob_dae_resrob</code>, you can do something like:</p><pre><code class="language-julia hljs">#] add DiffEqProblemLibrary
using DiffEqProblemLibrary.DAEProblemLibrary
# load problems
DAEProblemLibrary.importdaeproblems()
prob = DAEProblemLibrary.prob_dae_resrob
sol = solve(prob,IDA())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/dae_problems.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DDEProblem" href="#SciMLBase.DDEProblem"><code>SciMLBase.DDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a delay differential equation (DDE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/dde_types/</p><p><strong>Mathematical Specification of a DDE Problem</strong></p><p>To define a DDE Problem, you simply need to give the function <span>$f$</span>, the initial condition <span>$u_0$</span> at time point <span>$t_0$</span>, and the history function <span>$h$</span> which together define a DDE:</p><p class="math-container">\[\frac{du}{dt} = f(u,h,p,t) \qquad (t \geq t_0)\]</p><p class="math-container">\[u(t_0) = u_0,\]</p><p class="math-container">\[u(t) = h(t) \qquad (t &lt; t_0).\]</p><p><span>$f$</span> should be specified as <code>f(u, h, p, t)</code> (or in-place as <code>f(du, u, h, p, t)</code>), <span>$u_0$</span> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>, and <span>$h$</span> should be specified as described below. The history function <code>h</code> is accessed for all delayed values. Note that we are not limited to numbers or vectors for <span>$u_0$</span>; one is allowed to provide <span>$u_0$</span> as arbitrary matrices / higher dimension tensors as well.</p><p><strong>Functional Forms of the History Function</strong></p><p>The history function <code>h</code> can be called in the following ways:</p><ul><li><code>h(p, t)</code>: out-of-place calculation</li><li><code>h(out, p, t)</code>: in-place calculation</li><li><code>h(p, t, deriv::Type{Val{i}})</code>: out-of-place calculation of the <code>i</code>th derivative</li><li><code>h(out, p, t, deriv::Type{Val{i}})</code>: in-place calculation of the <code>i</code>th derivative</li><li><code>h(args...; idxs)</code>: calculation of <code>h(args...)</code> for indices <code>idxs</code></li></ul><p>Note that a dispatch for the supplied history function of matching form is required for whichever function forms are used in the user derivative function <code>f</code>.</p><p><strong>Declaring Lags</strong></p><p>Lags are declared separately from their use. One can use any lag by simply using the interpolant of <code>h</code> at that point. However, one should use caution in order to achieve the best accuracy. When lags are declared, the solvers can more efficiently be more accurate and thus this is recommended.</p><p><strong>Neutral and Retarded Delay Differential Equations</strong></p><p>Note that the history function specification can be used to specify general retarded arguments, i.e. <code>h(p,α(u,t))</code>. Neutral delay differential equations can be specified by using the <code>deriv</code> value in the history interpolation. For example, <code>h(p,t-τ, Val{1})</code> returns the first derivative of the history values at time <code>t-τ</code>.</p><p>Note that algebraic equations can be specified by using a singular mass matrix.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">DDEProblem(f[, u0], h, tspan[, p]; &lt;keyword arguments&gt;)
DDEProblem{isinplace}(f[, u0], h, tspan[, p]; &lt;keyword arguments&gt;)</code></pre><p>Parameter <code>isinplace</code> optionally sets whether the function is inplace or not. This is determined automatically, but not inferred.</p><p>Parameters are optional, and if not given then a <code>NullParameters()</code> singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>For specifying Jacobians and mass matrices, see the <a href="interfaces/@ref performance_overloads">DiffEqFunctions</a> page.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function in the DDE.</li><li><code>u0</code>: The initial condition. Defaults to the value <code>h(p, first(tspan))</code> of the history function evaluated at the initial time point.</li><li><code>h</code>: The history function for the DDE before <code>t0</code>.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>p</code>: The parameters with which function <code>f</code> is called. Defaults to <code>NullParameters</code>.</li><li><code>constant_lags</code>: A collection of constant lags used by the history function <code>h</code>. Defaults to <code>()</code>.</li><li><code>dependent_lags</code> A tuple of functions <code>(u, p, t) -&gt; lag</code> for the state-dependent lags used by the history function <code>h</code>. Defaults to <code>()</code>.</li><li><code>neutral</code>: If the DDE is neutral, i.e., if delays appear in derivative terms.</li><li><code>order_discontinuity_t0</code>: The order of the discontinuity at the initial time point. Defaults to <code>0</code> if an initial condition <code>u0</code> is provided. Otherwise it is forced to be greater or equal than <code>1</code>.</li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul><p><strong>Dynamical Delay Differential Equations</strong></p><p>Much like <a href="interfaces/@ref dynamical_prob">Dynamical ODEs</a>, a Dynamical DDE is a Partitioned DDE of the form:</p><p class="math-container">\[\frac{dv}{dt} = f_1(u,t,h) \\
\frac{du}{dt} = f_2(v,h) \\\]</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">DynamicalDDEProblem(f1, f2[, v0, u0], h, tspan[, p]; &lt;keyword arguments&gt;)
DynamicalDDEProblem{isinplace}(f1, f2[, v0, u0], h, tspan[, p]; &lt;keyword arguments&gt;)</code></pre><p>Parameter <code>isinplace</code> optionally sets whether the function is inplace or not. This is determined automatically, but not inferred.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function in the DDE.</li><li><code>v0</code> and <code>u0</code>: The initial condition. Defaults to the values <code>h(p, first(tspan))...</code> of the history function evaluated at the initial time point.</li><li><code>h</code>: The history function for the DDE before <code>t0</code>. Must return an object with the indices 1 and 2, with the values of <code>v</code> and <code>u</code> respectively.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>p</code>: The parameters with which function <code>f</code> is called. Defaults to <code>NullParameters</code>.</li><li><code>constant_lags</code>: A collection of constant lags used by the history function <code>h</code>. Defaults to <code>()</code>.</li><li><code>dependent_lags</code> A tuple of functions <code>(v, u, p, t) -&gt; lag</code> for the state-dependent lags used by the history function <code>h</code>. Defaults to <code>()</code>.</li><li><code>neutral</code>: If the DDE is neutral, i.e., if delays appear in derivative terms.</li><li><code>order_discontinuity_t0</code>: The order of the discontinuity at the initial time point. Defaults to <code>0</code> if an initial condition <code>u0</code> is provided. Otherwise it is forced to be greater or equal than <code>1</code>.</li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul><p>The for dynamical and second order DDEs, the history function will return an object with the indicies 1 and 2 defined, where <code>h(p, t_prev)[1]</code> is the value of <span>$f_2(v, u, h, p, t_{\mathrm{prev}})$</span> and <code>h(p, t_prev)[2]</code> is the value of <span>$f_1(v, u, h, p, t_{\mathrm{prev}})$</span> (this is for consistency with the ordering of the intitial conditions in the constructor). The supplied history function must also return such a 2-index object, which can be accomplished with a tuple <code>(v,u)</code> or vector <code>[v,u]</code>.</p><p><strong>2nd Order Delay Differential Equations</strong></p><p>To define a 2nd Order DDE Problem, you simply need to give the function <span>$f$</span> and the initial condition <span>$u_0$</span> which define an DDE:</p><p class="math-container">\[u&#39;&#39; = f(u&#39;,u,h,p,t)\]</p><p><code>f</code> should be specified as <code>f(du,u,p,t)</code> (or in-place as <code>f(ddu,du,u,p,t)</code>), and <code>u₀</code> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher dimension tensors as well.</p><p>From this form, a dynamical ODE:</p><p class="math-container">\[v&#39; = f(v,u,h,p,t) \\
u&#39; = v \\\]</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">SecondOrderDDEProblem(f, [, du0, u0], h, tspan[, p]; &lt;keyword arguments&gt;)
SecondOrderDDEProblem{isinplace}(f, [, du0, u0], h, tspan[, p]; &lt;keyword arguments&gt;)</code></pre><p>Parameter <code>isinplace</code> optionally sets whether the function is inplace or not. This is determined automatically, but not inferred.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function in the DDE.</li><li><code>du0</code> and <code>u0</code>: The initial condition. Defaults to the values <code>h(p, first(tspan))...</code> of the history function evaluated at the initial time point.</li><li><code>h</code>: The history function for the DDE before <code>t0</code>. Must return an object with the indices 1 and 2, with the values of <code>v</code> and <code>u</code> respectively.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>p</code>: The parameters with which function <code>f</code> is called. Defaults to <code>NullParameters</code>.</li><li><code>constant_lags</code>: A collection of constant lags used by the history function <code>h</code>. Defaults to <code>()</code>.</li><li><code>dependent_lags</code> A tuple of functions <code>(v, u, p, t) -&gt; lag</code> for the state-dependent lags used by the history function <code>h</code>. Defaults to <code>()</code>.</li><li><code>neutral</code>: If the DDE is neutral, i.e., if delays appear in derivative terms.</li><li><code>order_discontinuity_t0</code>: The order of the discontinuity at the initial time point. Defaults to <code>0</code> if an initial condition <code>u0</code> is provided. Otherwise it is forced to be greater or equal than <code>1</code>.</li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul><p>As above, the history function will return an object with indices 1 and 2, with the values of <code>du</code> and <code>u</code> respectively. The supplied history function must also match this return type, e.g. by returning a 2-element tuple or vector.</p><p><strong>Example Problems</strong></p><p>Example problems can be found in <a href="https://github.com/JuliaDiffEq/DiffEqProblemLibrary.jl/tree/master/src/dde">DiffEqProblemLibrary.jl</a>.</p><p>To use a sample problem, such as <code>prob_ode_linear</code>, you can do something like:</p><pre><code class="language-julia hljs">#] add DiffEqProblemLibrary
using DiffEqProblemLibrary.ODEProblemLibrary
# load problems
ODEProblemLibrary.importodeproblems()
prob = ODEProblemLibrary.prob_ode_linear
sol = solve(prob)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/dde_problems.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DynamicalDDEProblem" href="#SciMLBase.DynamicalDDEProblem"><code>SciMLBase.DynamicalDDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DynamicalDDEProblem{iip} &lt;: SciMLBase.AbstractDynamicalDDEProblem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/dde_problems.jl#L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SecondOrderDDEProblem" href="#SciMLBase.SecondOrderDDEProblem"><code>SciMLBase.SecondOrderDDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SecondOrderDDEProblem{iip} &lt;: SciMLBase.AbstractDynamicalDDEProblem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/dde_problems.jl#L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DiscreteProblem" href="#SciMLBase.DiscreteProblem"><code>SciMLBase.DiscreteProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a discrete dynamical system problem. Documentation Page: https://diffeq.sciml.ai/stable/types/discrete_types/</p><p><strong>Mathematical Specification of a Discrete Problem</strong></p><p>To define an Discrete Problem, you simply need to give the function <span>$f$</span> and the initial condition <span>$u_0$</span> which define a function map:</p><p class="math-container">\[u_{n+1} = f(u_{n},p,t_{n+1})\]</p><p><code>f</code> should be specified as <code>f(un,p,t)</code> (or in-place as <code>f(unp1,un,p,t)</code>), and <code>u_0</code> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher dimension tensors as well. <span>$u_{n+1}$</span> only depends on the previous iteration <span>$u_{n}$</span> and <span>$t_{n+1}$</span>. The default <span>$t_{n+1}$</span> of <code>FunctionMap</code> is <span>$t_n = t_0 + n*dt$</span> (with <code>dt=1</code> being the default). For continuous-time Markov chains this is the time at which the change is occuring.</p><p>Note that if the discrete solver is set to have <code>scale_by_time=true</code>, then the problem is interpreted as the map:</p><p class="math-container">\[u_{n+1} = u_n + dt f(u_{n},p,t_{n+1})\]</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><ul><li><code>DiscreteProblem{isinplace}(f::ODEFunction,u0,tspan,p=NullParameters();kwargs...)</code> : Defines the discrete problem with the specified functions.</li><li><code>DiscreteProblem{isinplace}(f,u0,tspan,p=NullParameters();kwargs...)</code> : Defines the discrete problem with the specified functions.</li><li><code>DiscreteProblem{isinplace}(u0,tspan,p=NullParameters();kwargs...)</code> : Defines the discrete problem with the identity map.</li></ul><p>Parameters are optional, and if not given then a <code>NullParameters()</code> singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>For specifying Jacobians and mass matrices, see the <a href="interfaces/@ref performance_overloads">DiffEqFunctions</a> page.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function in the map.</li><li><code>u0</code>: The initial condition.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code></li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul><p><strong>Note About Timing</strong></p><p>Note that if no <code>dt</code> and not <code>tstops</code> is given, it&#39;s assumed that <code>dt=1</code> and thus <code>tspan=(0,n)</code> will solve for <code>n</code> iterations. If in the solver <code>dt</code> is given, then the number of iterations will change. And if <code>tstops</code> is not empty, the solver will revert to the standard behavior of fixed timestep methods, which is &quot;step to each tstop&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/discrete_problems.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.NoiseProblem" href="#SciMLBase.NoiseProblem"><code>SciMLBase.NoiseProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NoiseProblem{N&lt;:SciMLBase.AbstractNoiseProcess, T, K} &lt;: SciMLBase.AbstractNoiseProblem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/noise_problems.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.ODEProblem" href="#SciMLBase.ODEProblem"><code>SciMLBase.ODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines an ordinary differential equation (ODE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/ode_types/</p><p><strong>Mathematical Specification of an ODE Problem</strong></p><p>To define an ODE Problem, you simply need to give the function <span>$f$</span> and the initial condition <span>$u_0$</span> which define an ODE:</p><p class="math-container">\[M \frac{du}{dt} = f(u,p,t)\]</p><p>There are two different ways of specifying <code>f</code>:</p><ul><li><code>f(du,u,p,t)</code>: in-place. Memory-efficient when avoiding allocations. Best option for most cases unless mutation is not allowed. </li><li><code>f(u,p,t)</code>: returning <code>du</code>. Less memory-efficient way, particularly suitable when mutation is not allowed (e.g. with certain automatic differentiation packages such as Zygote).</li></ul><p><code>u₀</code> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher dimension tensors as well.</p><p>For the mass matrix <span>$M$</span>, see the documentation of <code>ODEFunction</code>.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><p><code>ODEProblem</code> can be constructed by first building an <code>ODEFunction</code> or by simply passing the ODE right-hand side to the constructor. The constructors are:</p><ul><li><code>ODEProblem(f::ODEFunction,u0,tspan,p=NullParameters();kwargs...)</code></li><li><code>ODEProblem{isinplace}(f,u0,tspan,p=NullParameters();kwargs...)</code> : Defines the ODE with the specified functions. <code>isinplace</code> optionally sets whether the function is inplace or not. This is determined automatically, but not inferred.</li></ul><p>Parameters are optional, and if not given then a <code>NullParameters()</code> singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>For specifying Jacobians and mass matrices, see the <code>ODEFunction</code> documentation.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function in the ODE.</li><li><code>u0</code>: The initial condition.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>p</code>: The parameters.</li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul><p><strong>Example Problems</strong></p><p>Example problems can be found in <a href="https://github.com/JuliaDiffEq/DiffEqProblemLibrary.jl/tree/master/src/ode">DiffEqProblemLibrary.jl</a>.</p><p>To use a sample problem, such as <code>prob_ode_linear</code>, you can do something like:</p><pre><code class="language-julia hljs">#] add DiffEqProblemLibrary
using DiffEqProblemLibrary.ODEProblemLibrary
# load problems
ODEProblemLibrary.importodeproblems()
prob = ODEProblemLibrary.prob_ode_linear
sol = solve(prob)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/ode_problems.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DynamicalODEProblem" href="#SciMLBase.DynamicalODEProblem"><code>SciMLBase.DynamicalODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines an dynamical ordinary differential equation (ODE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/dynamical_types/</p><p>Dynamical ordinary differential equations, such as those arising from the definition of a Hamiltonian system or a second order ODE, have a special structure that can be utilized in the solution of the differential equation. On this page we describe how to define second order differential equations for their efficient numerical solution.</p><p><strong>Mathematical Specification of a Dynamical ODE Problem</strong></p><p>These algorithms require a Partitioned ODE of the form:</p><p class="math-container">\[\frac{dv}{dt} = f_1(u,t) \\
\frac{du}{dt} = f_2(v) \\\]</p><p>This is a Partitioned ODE partitioned into two groups, so the functions should be specified as <code>f1(dv,v,u,p,t)</code> and <code>f2(du,v,u,p,t)</code> (in the inplace form), where <code>f1</code> is independent of <code>v</code> (unless specified by the solver), and <code>f2</code> is independent of <code>u</code> and <code>t</code>. This includes discretizations arising from <code>SecondOrderODEProblem</code>s where the velocity is not used in the acceleration function, and Hamiltonians where the potential is (or can be) time-dependent but the kinetic energy is only dependent on <code>v</code>.</p><p>Note that some methods assume that the integral of <code>f2</code> is a quadratic form. That means that <code>f2=v&#39;*M*v</code>, i.e. <span>$\int f_2 = \frac{1}{2} m v^2$</span>, giving <code>du = v</code>. This is equivalent to saying that the kinetic energy is related to <span>$v^2$</span>. The methods which require this assumption will lose accuracy if this assumption is violated. Methods listed make note of this requirement with &quot;Requires quadratic kinetic energy&quot;.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DynamicalODEProblem(f::DynamicalODEFunction,v0,u0,tspan,p=NullParameters();kwargs...)
DynamicalODEProblem{isinplace}(f1,f2,v0,u0,tspan,p=NullParameters();kwargs...)</code></pre><p>Defines the ODE with the specified functions. <code>isinplace</code> optionally sets whether the function is inplace or not. This is determined automatically, but not inferred.</p><p>Parameters are optional, and if not given then a <code>NullParameters()</code> singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p><strong>Fields</strong></p><ul><li><code>f1</code> and <code>f2</code>: The functions in the ODE.</li><li><code>v0</code> and <code>u0</code>: The initial conditions.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code></li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/ode_problems.jl#L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SecondOrderODEProblem" href="#SciMLBase.SecondOrderODEProblem"><code>SciMLBase.SecondOrderODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a second order ordinary differential equation (ODE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/dynamical_types/</p><p><strong>Mathematical Specification of a 2nd Order ODE Problem</strong></p><p>To define a 2nd Order ODE Problem, you simply need to give the function <span>$f$</span> and the initial condition <span>$u_0$</span> which define an ODE:</p><p class="math-container">\[u&#39;&#39; = f(u&#39;,u,p,t)\]</p><p><code>f</code> should be specified as <code>f(du,u,p,t)</code> (or in-place as <code>f(ddu,du,u,p,t)</code>), and <code>u₀</code> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher dimension tensors as well.</p><p>From this form, a dynamical ODE:</p><p class="math-container">\[v&#39; = f(v,u,p,t) \\
u&#39; = v \\\]</p><p>is generated.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SecondOrderODEProblem{isinplace}(f,du0,u0,tspan,callback=CallbackSet())</code></pre><p>Defines the ODE with the specified functions.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function for the second derivative.</li><li><code>du0</code>: The initial derivative.</li><li><code>u0</code>: The initial condition.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>callback</code>: A callback to be applied to every solver which uses the problem. Defaults to nothing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/ode_problems.jl#L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SplitODEProblem" href="#SciMLBase.SplitODEProblem"><code>SciMLBase.SplitODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a split ordinary differential equation (ODE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/split<em>ode</em>types/</p><p><strong>Mathematical Specification of a Split ODE Problem</strong></p><p>To define a <code>SplitODEProblem</code>, you simply need to give a two functions  <span>$f_1$</span> and <span>$f_2$</span> along with an initial condition <span>$u_0$</span> which define an ODE:</p><p class="math-container">\[\frac{du}{dt} =  f_1(u,p,t) + f_2(u,p,t)\]</p><p><code>f</code> should be specified as <code>f(u,p,t)</code> (or in-place as <code>f(du,u,p,t)</code>), and <code>u₀</code> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher dimension tensors as well.</p><p>Many splits are at least partially linear. That is the equation:</p><p class="math-container">\[\frac{du}{dt} =  Au + f_2(u,p,t)\]</p><p>For how to define a linear function <code>A</code>, see the documentation for the <a href="interfaces/@ref">DiffEqOperators</a>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SplitODEProblem(f::SplitFunction,u0,tspan,p=NullParameters();kwargs...)
SplitODEProblem{isinplace}(f1,f2,u0,tspan,p=NullParameters();kwargs...)</code></pre><p>The <code>isinplace</code> parameter can be omitted and will be determined using the signature of <code>f2</code>. Note that both <code>f1</code> and <code>f2</code> should support the in-place style if <code>isinplace</code> is <code>true</code> or they should both support the out-of-place style if <code>isinplace</code> is <code>false</code>. You cannot mix up the two styles.</p><p>Parameters are optional, and if not given then a <code>NullParameters()</code> singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>Under the hood, a <code>SplitODEProblem</code> is just a regular <code>ODEProblem</code> whose <code>f</code> is a <code>SplitFunction</code>. Therefore you can solve a <code>SplitODEProblem</code> using the same solvers for <code>ODEProblem</code>. For solvers dedicated to split problems, see <a href="interfaces/@ref split_ode_solve">Split ODE Solvers</a>.</p><p>For specifying Jacobians and mass matrices, see the <a href="interfaces/@ref performance_overloads">DiffEqFunctions</a> page.</p><p><strong>Fields</strong></p><ul><li><code>f1</code>, <code>f2</code>: The functions in the ODE.</li><li><code>u0</code>: The initial condition.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code></li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/ode_problems.jl#L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.IncrementingODEProblem" href="#SciMLBase.IncrementingODEProblem"><code>SciMLBase.IncrementingODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Experimental</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/ode_problems.jl#L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.RODEProblem" href="#SciMLBase.RODEProblem"><code>SciMLBase.RODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a random ordinary differential equation (RODE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/rode_types/</p><p><strong>Mathematical Specification of a RODE Problem</strong></p><p>To define a RODE Problem, you simply need to give the function <span>$f$</span> and the initial condition <span>$u_0$</span> which define an ODE:</p><p class="math-container">\[\frac{du}{dt} = f(u,p,t,W(t))\]</p><p>where <code>W(t)</code> is a random process. <code>f</code> should be specified as <code>f(u,p,t,W)</code> (or in-place as <code>f(du,u,p,t,W)</code>), and <code>u₀</code> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher dimension tensors as well.</p><p><strong>Constructors</strong></p><ul><li><code>RODEProblem(f::RODEFunction,u0,tspan,p=NullParameters();noise=WHITE_NOISE,rand_prototype=nothing,callback=nothing)</code></li><li><code>RODEProblem{isinplace}(f,u0,tspan,p=NullParameters();noise=WHITE_NOISE,rand_prototype=nothing,callback=nothing,mass_matrix=I)</code> : Defines the RODE with the specified functions. The default noise is <code>WHITE_NOISE</code>. <code>isinplace</code> optionally sets whether the function is inplace or not. This is determined automatically, but not inferred.</li></ul><p>Parameters are optional, and if not given then a <code>NullParameters()</code> singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>For specifying Jacobians and mass matrices, see the <a href="interfaces/@ref performance_overloads">DiffEqFunctions</a> page.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The drift function in the SDE.</li><li><code>u0</code>: The initial condition.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>p</code>: The optional parameters for the problem. Defaults to <code>NullParameters</code>.</li><li><code>noise</code>: The noise process applied to the noise upon generation. Defaults to Gaussian white noise. For information on defining different noise processes, see <a href="interfaces/@ref noise_process">the noise process documentation page</a></li><li><code>rand_prototype</code>: A prototype type instance for the noise vector. It defaults to <code>nothing</code>, which means the problem should be interpreted as having a noise vector whose size matches <code>u0</code>.</li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/rode_problems.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SDDEProblem" href="#SciMLBase.SDDEProblem"><code>SciMLBase.SDDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines a stochastic delay differential equation (SDDE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/sdde_types/</p><p><strong>Mathematical Specification of a Stochastic Delay Differential Equation (SDDE) Problem</strong></p><p>To define a SDDE Problem, you simply need to give the drift function <span>$f$</span>, the diffusion function <code>g</code>, the initial condition <span>$u_0$</span> at time point <span>$t_0$</span>, and the history function <span>$h$</span> which together define a SDDE:</p><p class="math-container">\[du = f(u,h,p,t)dt + g(u,h,p,t)dW_t \qquad (t \geq t_0)\]</p><p class="math-container">\[u(t_0) = u_0,\]</p><p class="math-container">\[u(t) = h(t) \qquad (t &lt; t_0).\]</p><p><span>$f$</span> should be specified as <code>f(u, h, p, t)</code> (or in-place as <code>f(du, u, h, p, t)</code>) (and <span>$g$</span> should match). <span>$u_0$</span> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>, and <span>$h$</span> should be specified as described below. The history function <code>h</code> is accessed for all delayed values. Note that we are not limited to numbers or vectors for <span>$u_0$</span>; one is allowed to provide <span>$u_0$</span> as arbitrary matrices / higher dimension tensors as well.</p><p>Note that this functionality should be considered experimental.</p><p><strong>Functional Forms of the History Function</strong></p><p>The history function <code>h</code> can be called in the following ways:</p><ul><li><code>h(p, t)</code>: out-of-place calculation</li><li><code>h(out, p, t)</code>: in-place calculation</li><li><code>h(p, t, deriv::Type{Val{i}})</code>: out-of-place calculation of the <code>i</code>th derivative</li><li><code>h(out, p, t, deriv::Type{Val{i}})</code>: in-place calculation of the <code>i</code>th derivative</li><li><code>h(args...; idxs)</code>: calculation of <code>h(args...)</code> for indices <code>idxs</code></li></ul><p>Note that a dispatch for the supplied history function of matching form is required for whichever function forms are used in the user derivative function <code>f</code>.</p><p><strong>Declaring Lags</strong></p><p>Lags are declared separately from their use. One can use any lag by simply using the interpolant of <code>h</code> at that point. However, one should use caution in order to achieve the best accuracy. When lags are declared, the solvers can more efficiently be more accurate and thus this is recommended.</p><p><strong>Neutral, Retarded, and Algebraic Stochastic Delay Differential Equations</strong></p><p>Note that the history function specification can be used to specify general retarded arguments, i.e. <code>h(p,α(u,t))</code>. Neutral delay differential equations can be specified by using the <code>deriv</code> value in the history interpolation. For example, <code>h(p,t-τ, Val{1})</code> returns the first derivative of the history values at time <code>t-τ</code>.</p><p>Note that algebraic equations can be specified by using a singular mass matrix.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">SDDEProblem(f,g[, u0], h, tspan[, p]; &lt;keyword arguments&gt;)
SDDEProblem{isinplace}(f,g[, u0], h, tspan[, p]; &lt;keyword arguments&gt;)</code></pre><p>Parameter <code>isinplace</code> optionally sets whether the function is inplace or not. This is determined automatically, but not inferred.</p><p>Parameters are optional, and if not given then a <code>NullParameters()</code> singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>For specifying Jacobians and mass matrices, see the <a href="interfaces/@ref performance_overloads">DiffEqFunctions</a> page.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The drift function in the SDDE.</li><li><code>g</code>: The diffusion function in the SDDE.</li><li><code>u0</code>: The initial condition. Defaults to the value <code>h(p, first(tspan))</code> of the history function evaluated at the initial time point.</li><li><code>h</code>: The history function for the DDE before <code>t0</code>.</li><li><code>tspan</code>: The timespan for the problem.</li><li><code>p</code>: The parameters with which function <code>f</code> is called. Defaults to <code>NullParameters</code>.</li><li><code>constant_lags</code>: A collection of constant lags used by the history function <code>h</code>. Defaults to <code>()</code>.</li><li><code>dependent_lags</code> A tuple of functions <code>(u, p, t) -&gt; lag</code> for the state-dependent lags used by the history function <code>h</code>. Defaults to <code>()</code>.</li><li><code>neutral</code>: If the DDE is neutral, i.e., if delays appear in derivative terms.</li><li><code>order_discontinuity_t0</code>: The order of the discontinuity at the initial time point. Defaults to <code>0</code> if an initial condition <code>u0</code> is provided. Otherwise it is forced to be greater or equal than <code>1</code>.</li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/sdde_problems.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SplitSDEProblem" href="#SciMLBase.SplitSDEProblem"><code>SciMLBase.SplitSDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SplitSDEProblem{iip} &lt;: SciMLBase.AbstractSplitSDEProblem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/sde_problems.jl#L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DynamicalSDEProblem" href="#SciMLBase.DynamicalSDEProblem"><code>SciMLBase.DynamicalSDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DynamicalSDEProblem{iip} &lt;: SciMLBase.AbstractDynamicalSDEProblem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/sde_problems.jl#L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SteadyStateProblem" href="#SciMLBase.SteadyStateProblem"><code>SciMLBase.SteadyStateProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Defines an Defines a steady state ODE problem. Documentation Page: https://diffeq.sciml.ai/stable/types/steady<em>state</em>types/</p><p><strong>Mathematical Specification of a Steady State Problem</strong></p><p>To define an Steady State Problem, you simply need to give the function <span>$f$</span> which defines the ODE:</p><p class="math-container">\[\frac{du}{dt} = f(u,p,t)\]</p><p>and an initial guess <span>$u_0$</span> of where <code>f(u,p,t)=0</code>. <code>f</code> should be specified as <code>f(u,p,t)</code> (or in-place as <code>f(du,u,p,t)</code>), and <code>u₀</code> should be an AbstractArray (or number) whose geometry matches the desired geometry of <code>u</code>. Note that we are not limited to numbers or vectors for <code>u₀</code>; one is allowed to provide <code>u₀</code> as arbitrary matrices / higher dimension tensors as well.</p><p>Note that for the steady-state to be defined, we must have that <code>f</code> is autonomous, that is <code>f</code> is independent of <code>t</code>. But the form which matches the standard ODE solver should still be used. The steady state solvers interpret the <code>f</code> by fixing <code>t=0</code>.</p><p><strong>Problem Type</strong></p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SteadyStateProblem(f::ODEFunction,u0,p=NullParameters();kwargs...)
SteadyStateProblem{isinplace}(f,u0,p=NullParameters();kwargs...)</code></pre><p><code>isinplace</code> optionally sets whether the function is inplace or not. This is determined automatically, but not inferred. Additionally, the constructor from <code>ODEProblem</code>s is provided:</p><pre><code class="language-julia hljs">SteadyStateProblem(prob::ODEProblem)</code></pre><p>Parameters are optional, and if not given then a <code>NullParameters()</code> singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a <code>callback</code> in the problem, then that <code>callback</code> will be added in every solve call.</p><p>For specifying Jacobians and mass matrices, see the <a href="interfaces/@ref performance_overloads">DiffEqFunctions</a> page.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: The function in the ODE.</li><li><code>u0</code>: The initial guess for the steady state.</li><li><code>p</code>: The parameters for the problem. Defaults to <code>NullParameters</code></li><li><code>kwargs</code>: The keyword arguments passed onto the solves.</li></ul><p><strong>Special Solution Fields</strong></p><p>The <code>SteadyStateSolution</code> type is different from the other DiffEq solutions because it does not have temporal information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/steady_state_problems.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.PDEProblem" href="#SciMLBase.PDEProblem"><code>SciMLBase.PDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PDEProblem{P, E, S} &lt;: SciMLBase.AbstractPDEProblem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/ab2302070db95b3e90922787f7a2e4586e9d2e00/src/problems/pde_problems.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../SciMLFunctions/">SciMLFunctions (Jacobians, Sparsity, Etc.) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Saturday 11 June 2022 05:43">Saturday 11 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
