<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SciMLFunctions (Jacobians, Sparsity, Etc.) · SciMLBase.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://scimlbase.sciml.ai/stable/interfaces/SciMLFunctions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SciMLBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SciMLBase.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../Problems/">SciMLProblems</a></li><li class="is-active"><a class="tocitem" href>SciMLFunctions (Jacobians, Sparsity, Etc.)</a><ul class="internal"><li><a class="tocitem" href="#Definition-of-the-AbstractSciMLFunction-Interface"><span>Definition of the AbstractSciMLFunction Interface</span></a></li><li><a class="tocitem" href="#Traits"><span>Traits</span></a></li><li><a class="tocitem" href="#AbstractSciMLFunction-API"><span>AbstractSciMLFunction API</span></a></li></ul></li><li><a class="tocitem" href="../Algorithms/">SciMLAlgorithms</a></li><li><a class="tocitem" href="../Solutions/">SciMLSolutions</a></li><li><a class="tocitem" href="../Init_Solve/">The SciML init and solve Functions</a></li><li><a class="tocitem" href="../Common_Keywords/">Common Keyword Arguments</a></li><li><a class="tocitem" href="../Differentiation/">Automatic Differentiation and Sensitivity Algorithms (Adjoints)</a></li><li><a class="tocitem" href="../PDE/">The PDE Definition Interface</a></li></ul></li><li><span class="tocitem">Fundamentals</span><ul><li><a class="tocitem" href="../../fundamentals/FAQ/">Frequently Asked Questions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Interfaces</a></li><li class="is-active"><a href>SciMLFunctions (Jacobians, Sparsity, Etc.)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SciMLFunctions (Jacobians, Sparsity, Etc.)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLBase.jl/blob/master/docs/src/interfaces/SciMLFunctions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="scimlfunctions"><a class="docs-heading-anchor" href="#scimlfunctions">SciMLFunctions (Jacobians, Sparsity, Etc.)</a><a id="scimlfunctions-1"></a><a class="docs-heading-anchor-permalink" href="#scimlfunctions" title="Permalink"></a></h1><p>The SciML ecosystem provides an extensive interface for declaring extra functions associated with the differential equation&#39;s data. In traditional libraries there is usually only one option: the Jacobian. However, we allow for a large array of pre-computed functions to speed up the calculations. This is offered via the <code>SciMLFunction</code> types which can be passed to the problems.</p><h2 id="Definition-of-the-AbstractSciMLFunction-Interface"><a class="docs-heading-anchor" href="#Definition-of-the-AbstractSciMLFunction-Interface">Definition of the AbstractSciMLFunction Interface</a><a id="Definition-of-the-AbstractSciMLFunction-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-AbstractSciMLFunction-Interface" title="Permalink"></a></h2><p>The following standard principles should be adhered to across all  <code>AbstractSciMLFunction</code> instantiations.</p><h3 id="Common-Function-Choice-Definitions"><a class="docs-heading-anchor" href="#Common-Function-Choice-Definitions">Common Function Choice Definitions</a><a id="Common-Function-Choice-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Function-Choice-Definitions" title="Permalink"></a></h3><p>The full interface available to the solvers is as follows:</p><ul><li><code>jac</code>: The Jacobian of the differential equation with respect to the state variable <code>u</code> at a time <code>t</code> with parameters <code>p</code>.</li><li><code>paramjac</code>: The Jacobian of the differential equation with respect to <code>p</code> at state <code>u</code> at time <code>t</code>.</li><li><code>analytic</code>: Defines an analytical solution using <code>u0</code> at time <code>t</code> with <code>p</code> which will cause the solvers to return errors. Used for testing.</li><li><code>syms</code>: Allows you to name your variables for automatic names in plots and other output.</li><li><code>jac_prototype</code>: Defines the type to be used for any internal Jacobians within the solvers.</li><li><code>sparsity</code>: Defines the sparsity pattern to be used for the sparse differentiation schemes. By default this is equal to <code>jac_prototype</code>. See the sparsity handling portion of this page for more information.</li><li><code>colorvec</code>: The coloring pattern used by the sparse differentiator. See the sparsity handling portion of this page for more information.</li><li><code>observed</code>: A function which allows for generating other observables from a solution.</li></ul><p>Each function type additionally has some specific arguments, refer to their documentation for details.</p><h3 id="In-place-Specification-and-No-Recompile-Mode"><a class="docs-heading-anchor" href="#In-place-Specification-and-No-Recompile-Mode">In-place Specification and No-Recompile Mode</a><a id="In-place-Specification-and-No-Recompile-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#In-place-Specification-and-No-Recompile-Mode" title="Permalink"></a></h3><p>Each SciMLFunction type can be called with an &quot;is inplace&quot; (iip) choice.</p><pre><code class="language-julia hljs">ODEFunction(f)
ODEFunction{iip}(f)</code></pre><p>which is a boolean for whether the function is in the inplace form (mutating to change the first value). This is automatically determined using the methods table but note that for full type-inferrability of the <code>SciMLProblem</code> this iip-ness should be specified.</p><p>Additionally, the functions are fully specialized to reduce the runtimes. If one would instead like to not specialize on the functions to reduce compile time, then one can set <code>recompile</code> to false.</p><pre><code class="language-julia hljs">ODEFunction{iip,false}(f)</code></pre><p>This makes the ODE solver compilation independent of the function and so changing the function will not cause recompilation. One can change the default value by changing the <code>const RECOMPILE_BY_DEFAULT = true</code> to false in the SciMLBase.jl source code.</p><h3 id="Specifying-Jacobian-Types"><a class="docs-heading-anchor" href="#Specifying-Jacobian-Types">Specifying Jacobian Types</a><a id="Specifying-Jacobian-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-Jacobian-Types" title="Permalink"></a></h3><p>The <code>jac</code> field of an inplace style <code>SciMLFunction</code> has the signature <code>jac(J,u,p,t)</code>, which updates the jacobian <code>J</code> in-place. The intended type for <code>J</code> can sometimes be inferred (e.g. when it is just a dense <code>Matrix</code>), but not in general. To supply the type information, you can provide a <code>jac_prototype</code> in the function&#39;s constructor.</p><p>The following example creates an inplace <code>ODEFunction</code> whose jacobian is a <code>Diagonal</code>:</p><pre><code class="language-julia hljs">using LinearAlgebra
f = (du,u,p,t) -&gt; du .= t .* u
jac = (J,u,p,t) -&gt; (J[1,1] = t; J[2,2] = t; J)
jp = Diagonal(zeros(2))
fun = ODEFunction(f; jac=jac, jac_prototype=jp)</code></pre><p>Note that the integrators will always make a deep copy of <code>fun.jac_prototype</code>, so there&#39;s no worry of aliasing.</p><p>In general the jacobian prototype can be anything that has <code>mul!</code> defined, in particular sparse matrices or custom lazy types that support <code>mul!</code>. A special case is when the <code>jac_prototype</code> is a <code>AbstractDiffEqLinearOperator</code>, in which case you do not need to supply <code>jac</code> as it is automatically set to <code>update_coefficients!</code>. Refer to the <a href="interfaces/@ref">DiffEqOperators</a> section for more information on setting up time/parameter dependent operators.</p><h3 id="Sparsity-Handling"><a class="docs-heading-anchor" href="#Sparsity-Handling">Sparsity Handling</a><a id="Sparsity-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Sparsity-Handling" title="Permalink"></a></h3><p>The solver libraries internally use packages such as <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a> and <a href="https://github.com/JuliaDiff/SparseDiffTools.jl">SparseDiffTools.jl</a> for high performance calculation of sparse Jacobians and Hessians, along with matrix-free calculations of Jacobian-Vector products (J<em>v), vector-Jacobian products (v&#39;</em>J), and Hessian-vector products (H*v). The SciML interface gives users the ability to control these connections in order to allow for top notch performance.</p><p>The key arguments in the SciMLFunction is the <code>prototype</code>, which is an object that will be used as the underlying Jacobian/Hessian. Thus if one wants to use a sparse Jacobian, one should specify <code>jac_prototype</code> to be a sparse matrix. The sparsity pattern used in the differentiation scheme is defined by <code>sparsity</code>. By default, <code>sparsity=jac_prototype</code>, meaning that the sparse automatic differentiation scheme should specialize on the sparsity pattern given by the actual sparsity pattern. This can be overridden to say perform partial matrix coloring approximations. Additionally, the color vector for the sparse differentiation directions can be specified directly via <code>colorvec</code>. For more information on how these arguments control the differentiation process, see the aforementioned differentiation library documentations.</p><h2 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SciMLBase.isinplace(f::SciMLBase.AbstractSciMLFunction)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="AbstractSciMLFunction-API"><a class="docs-heading-anchor" href="#AbstractSciMLFunction-API">AbstractSciMLFunction API</a><a id="AbstractSciMLFunction-API-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractSciMLFunction-API" title="Permalink"></a></h2><h3 id="Abstract-SciML-Functions"><a class="docs-heading-anchor" href="#Abstract-SciML-Functions">Abstract SciML Functions</a><a id="Abstract-SciML-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-SciML-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractDiffEqFunction" href="#SciMLBase.AbstractDiffEqFunction"><code>SciMLBase.AbstractDiffEqFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDiffEqFunction{iip} &lt;: SciMLBase.AbstractSciMLFunction{iip}</code></pre><p>Base for types defining differential equation functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/SciMLBase.jl#L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractODEFunction" href="#SciMLBase.AbstractODEFunction"><code>SciMLBase.AbstractODEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractODEFunction{iip} &lt;: SciMLBase.AbstractDiffEqFunction{iip}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractSDEFunction" href="#SciMLBase.AbstractSDEFunction"><code>SciMLBase.AbstractSDEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSDEFunction{iip} &lt;: SciMLBase.AbstractDiffEqFunction{iip}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractDDEFunction" href="#SciMLBase.AbstractDDEFunction"><code>SciMLBase.AbstractDDEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDDEFunction{iip} &lt;: SciMLBase.AbstractDiffEqFunction{iip}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractDAEFunction" href="#SciMLBase.AbstractDAEFunction"><code>SciMLBase.AbstractDAEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDAEFunction{iip} &lt;: SciMLBase.AbstractDiffEqFunction{iip}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L1143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractRODEFunction" href="#SciMLBase.AbstractRODEFunction"><code>SciMLBase.AbstractRODEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractRODEFunction{iip} &lt;: SciMLBase.AbstractDiffEqFunction{iip}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L1041">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractDiscreteFunction" href="#SciMLBase.AbstractDiscreteFunction"><code>SciMLBase.AbstractDiscreteFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDiscreteFunction{iip} &lt;: SciMLBase.AbstractDiffEqFunction{iip}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractSDDEFunction" href="#SciMLBase.AbstractSDDEFunction"><code>SciMLBase.AbstractSDDEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSDDEFunction{iip} &lt;: SciMLBase.AbstractDiffEqFunction{iip}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L1285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.AbstractNonlinearFunction" href="#SciMLBase.AbstractNonlinearFunction"><code>SciMLBase.AbstractNonlinearFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractNonlinearFunction{iip} &lt;: SciMLBase.AbstractSciMLFunction{iip}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L1391">source</a></section></article><h3 id="Concrete-SciML-Functions"><a class="docs-heading-anchor" href="#Concrete-SciML-Functions">Concrete SciML Functions</a><a id="Concrete-SciML-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-SciML-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.ODEFunction" href="#SciMLBase.ODEFunction"><code>SciMLBase.ODEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ODEFunction{iip,F,TMM,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,S2,O,TCV} &lt;: AbstractODEFunction{iip}</p><p>A representation of an ODE function <code>f</code>, defined by:</p><p class="math-container">\[M \frac{du}{dt} = f(u,p,t)\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">ODEFunction{iip,recompile}(f;
                           mass_matrix=I,
                           analytic=nothing,
                           tgrad=nothing,
                           jac=nothing,
                           jvp=nothing,
                           vjp=nothing,
                           jac_prototype=nothing,
                           sparsity=jac_prototype,
                           paramjac = nothing,
                           syms = nothing,
                           indepsym = nothing,
                           colorvec = nothing)</code></pre><p>Note that only the function <code>f</code> itself is required. This function should be given as <code>f!(du,u,p,t)</code> or <code>du = f(u,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M</code> represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/dae_solve/. Must be an AbstractArray or an AbstractSciMLOperator.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,p,t)</code> or dT=tgrad(u,p,t): returns <span>$\frac{\partial f(u,p,t)}{\partial t}$</span></li><li><code>jac(J,u,p,t)</code> or <code>J=jac(u,p,t)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>jvp(Jv,v,u,p,t)</code> or <code>Jv=jvp(v,u,p,t)</code>: returns the directional derivative<span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,u,p,t)</code> or <code>Jv=vjp(v,u,p,t)</code>: returns the adjoint derivative<span>$\frac{df}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p><code>iip</code> is the the optional boolean for determining whether a given function is written to be used in-place or out-of-place. In-place functions are <code>f!(du,u,p,t)</code> where the return is ignored and the result is expected to be mutated into the value of <code>du</code>. Out-of-place functions are <code>du=f(u,p,t)</code>.</p><p>Normally this is determined automatically by looking at the method table for <code>f</code> and seeing the maximum number of arguments in available dispatches. For this reason, the constructor <code>ODEFunction(f)</code> generally works (but is type-unstable). However, for type-stability or to enforce correctness, this option is passed via <code>ODEFunction{true}(f)</code>.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>The <code>recompile</code> parameter controls whether the ODEFunction will fully specialize on the <code>typeof(f)</code>. This causes recompilation of the solver for each new <code>f</code> function, but gives the maximum compiler information and runtime speed. By default <code>recompile = true</code>. If <code>recompile = false</code>, the <code>ODEFunction</code> uses <code>Any</code> type parameters for each of the functions, allowing for the reuse of compilation caches but adding a dynamic dispatch at the <code>f</code> call sites, potentially leading to runtime regressions.</p><p>Overriding the <code>true</code> default is done by passing a second type parameter after <code>iip</code>, for example <code>ODEFunction{true,false}(f)</code> is an in-place function with no recompilation specialization.</p><p><strong>Fields</strong></p><p>The fields of the ODEFunction type directly match the names of the inputs.</p><p><strong>More Details on Jacobians</strong></p><p>The following example creates an inplace <code>ODEFunction</code> whose jacobian is a <code>Diagonal</code>:</p><pre><code class="language-julia hljs">using LinearAlgebra
f = (du,u,p,t) -&gt; du .= t .* u
jac = (J,u,p,t) -&gt; (J[1,1] = t; J[2,2] = t; J)
jp = Diagonal(zeros(2))
fun = ODEFunction(f; jac=jac, jac_prototype=jp)</code></pre><p>Note that the integrators will always make a deep copy of <code>fun.jac_prototype</code>, so there&#39;s no worry of aliasing.</p><p>In general the jacobian prototype can be anything that has <code>mul!</code> defined, in particular sparse matrices or custom lazy types that support <code>mul!</code>. A special case is when the <code>jac_prototype</code> is a <code>AbstractDiffEqLinearOperator</code>, in which case you do not need to supply <code>jac</code> as it is automatically set to <code>update_coefficients!</code>. Refer to the AbstractSciMLOperators documentation for more information on setting up time/parameter dependent operators.</p><p><strong>Examples</strong></p><p><strong>Declaring Explicit Jacobians for ODEs</strong></p><p>The most standard case, declaring a function for a Jacobian is done by overloading the function <code>f(du,u,p,t)</code> with an in-place updating function for the Jacobian: <code>f_jac(J,u,p,t)</code> where the value type is used for dispatch. For example, take the LotkaVolterra model:</p><pre><code class="language-julia hljs">function f(du,u,p,t)
  du[1] = 2.0 * u[1] - 1.2 * u[1]*u[2]
  du[2] = -3 * u[2] + u[1]*u[2]
end</code></pre><p>To declare the Jacobian we simply add the dispatch:</p><pre><code class="language-julia hljs">function f_jac(J,u,p,t)
  J[1,1] = 2.0 - 1.2 * u[2]
  J[1,2] = -1.2 * u[1]
  J[2,1] = 1 * u[2]
  J[2,2] = -3 + u[1]
  nothing
end</code></pre><p>Then we can supply the Jacobian with our ODE as:</p><pre><code class="language-julia hljs">ff = ODEFunction(f;jac=f_jac)</code></pre><p>and use this in an <code>ODEProblem</code>:</p><pre><code class="language-julia hljs">prob = ODEProblem(ff,ones(2),(0.0,10.0))</code></pre><p><strong>Symbolically Generating the Functions</strong></p><p>See the <code>modelingtoolkitize</code> function from <a href="https://github.com/JuliaDiffEq/ModelingToolkit.jl">ModelingToolkit.jl</a> for automatically symbolically generating the Jacobian and more from the  numerically-defined functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SplitFunction" href="#SciMLBase.SplitFunction"><code>SciMLBase.SplitFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SplitFunction{iip,F1,F2,TMM,C,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,O,TCV} &lt;: AbstractODEFunction{iip}</p><p>A representation of a split ODE function <code>f</code>, defined by:</p><p class="math-container">\[M \frac{du}{dt} = f_1(u,p,t) + f_2(u,p,t)\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p>Generally, for ODE integrators the <code>f_1</code> portion should be considered the &quot;stiff portion of the model&quot; with larger time scale separation, while the <code>f_2</code> portion should be considered the &quot;non-stiff portion&quot;. This interpretation is directly used in integrators like IMEX (implicit-explicit integrators) and exponential integrators.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SplitFunction{iip,recompile}(f1,f2;
                             mass_matrix=I,
                             analytic=nothing,
                             tgrad=nothing,
                             jac=nothing,
                             jvp=nothing,
                             vjp=nothing,
                             jac_prototype=nothing,
                             sparsity=jac_prototype,
                             paramjac = nothing,
                             syms = nothing,
                             indepsym = nothing,
                             colorvec = nothing)</code></pre><p>Note that only the functions <code>f_i</code> themselves are required. These functions should be given as <code>f_i!(du,u,p,t)</code> or <code>du = f_i(u,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M</code> represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/dae_solve/. Must be an AbstractArray or an AbstractSciMLOperator.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,p,t)</code> or dT=tgrad(u,p,t): returns <span>$\frac{\partial f_1(u,p,t)}{\partial t}$</span></li><li><code>jac(J,u,p,t)</code> or <code>J=jac(u,p,t)</code>: returns <span>$\frac{df_1}{du}$</span></li><li><code>jvp(Jv,v,u,p,t)</code> or <code>Jv=jvp(v,u,p,t)</code>: returns the directional derivative<span>$\frac{df_1}{du} v$</span></li><li><code>vjp(Jv,v,u,p,t)</code> or <code>Jv=vjp(v,u,p,t)</code>: returns the adjoint derivative<span>$\frac{df_1}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df_1}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>Note on the Derivative Definition</strong></p><p>The derivatives, such as the Jacobian, are only defined on the <code>f1</code> portion of the split ODE. This is used to treat the <code>f1</code> implicit while keeping the <code>f2</code> portion explicit.</p><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the SplitFunction type directly match the names of the inputs.</p><p><strong>Symbolically Generating the Functions</strong></p><p>See the <code>modelingtoolkitize</code> function from <a href="https://github.com/JuliaDiffEq/ModelingToolkit.jl">ModelingToolkit.jl</a> for automatically symbolically generating the Jacobian and more from the  numerically-defined functions. See <code>ModelingToolkit.SplitODEProblem</code> for information on generating the SplitFunction from this symbolic engine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DynamicalODEFunction" href="#SciMLBase.DynamicalODEFunction"><code>SciMLBase.DynamicalODEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DynamicalODEFunction{iip,F1,F2,TMM,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,O,TCV} &lt;: AbstractODEFunction{iip}</p><p>A representation of an ODE function <code>f</code>, defined by:</p><p class="math-container">\[M \frac{du}{dt} = f(u,p,t)\]</p><p>as a partitioned ODE:</p><p class="math-container">\[M_1 \frac{du}{dt} = f_1(u,p,t)
M_2 \frac{du}{dt} = f_2(u,p,t)\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DynamicalODEFunction{iip,recompile}(f1,f2;
                                    mass_matrix=I,
                                    analytic=nothing,
                                    tgrad=nothing,
                                    jac=nothing,
                                    jvp=nothing,
                                    vjp=nothing,
                                    jac_prototype=nothing,
                                    sparsity=jac_prototype,
                                    paramjac = nothing,
                                    syms = nothing,
                                    indepsym = nothing,
                                    colorvec = nothing)</code></pre><p>Note that only the functions <code>f_i</code> themselves are required. These functions should be given as <code>f_i!(du,u,p,t)</code> or <code>du = f_i(u,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M_i</code> represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/dae<em>solve/. Must be an AbstractArray or an AbstractSciMLOperator. Should be given as a tuple of mass matrices, i.e. `(M</em>1, M_2)` for the mass matrices of equations 1 and 2 respectively.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,p,t)</code> or dT=tgrad(u,p,t): returns <span>$\frac{\partial f(u,p,t)}{\partial t}$</span></li><li><code>jac(J,u,p,t)</code> or <code>J=jac(u,p,t)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>jvp(Jv,v,u,p,t)</code> or <code>Jv=jvp(v,u,p,t)</code>: returns the directional derivative<span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,u,p,t)</code> or <code>Jv=vjp(v,u,p,t)</code>: returns the adjoint derivative<span>$\frac{df}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the DynamicalODEFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DDEFunction" href="#SciMLBase.DDEFunction"><code>SciMLBase.DDEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DDEFunction{iip,F,TMM,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,O,TCV} &lt;: AbstractDDEFunction{iip}</p><p>A representation of a DDE function <code>f</code>, defined by:</p><p class="math-container">\[M \frac{du}{dt} = f(u,h,p,t)\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DDEFunction{iip,recompile}(f;
                 mass_matrix=I,
                 analytic=nothing,
                 tgrad=nothing,
                 jac=nothing,
                 jvp=nothing,
                 vjp=nothing,
                 jac_prototype=nothing,
                 sparsity=jac_prototype,
                 paramjac = nothing,
                 syms = nothing,
                 indepsym = nothing,
                 colorvec = nothing)</code></pre><p>Note that only the function <code>f</code> itself is required. This function should be given as <code>f!(du,u,h,p,t)</code> or <code>du = f(u,h,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling. The histroy function <code>h</code> acts as an interpolator over time, i.e. <code>h(t)</code> with options matching the solution interface, i.e. <code>h(t; save_idxs = 2)</code>.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M</code> represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/dae_solve/. Must be an AbstractArray or an AbstractSciMLOperator.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,h,p,t)</code> or dT=tgrad(u,p,t): returns <span>$\frac{\partial f(u,p,t)}{\partial t}$</span></li><li><code>jac(J,u,h,p,t)</code> or <code>J=jac(u,p,t)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>jvp(Jv,v,h,u,p,t)</code> or <code>Jv=jvp(v,u,p,t)</code>: returns the directional derivative<span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,h,u,p,t)</code> or <code>Jv=vjp(v,u,p,t)</code>: returns the adjoint derivative<span>$\frac{df}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,h,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the DDEFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DynamicalDDEFunction" href="#SciMLBase.DynamicalDDEFunction"><code>SciMLBase.DynamicalDDEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DynamicalDDEFunction{iip,F1,F2,TMM,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,O,TCV} &lt;: AbstractDDEFunction{iip}</p><p>A representation of a DDE function <code>f</code>, defined by:</p><p class="math-container">\[M \frac{du}{dt} = f(u,h,p,t)\]</p><p>as a partitioned ODE:</p><p class="math-container">\[M_1 \frac{du}{dt} = f_1(u,h,p,t)
M_2 \frac{du}{dt} = f_2(u,h,p,t)\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DynamicalDDEFunction{iip,recompile}(f1,f2;
                                    mass_matrix=I,
                                    analytic=nothing,
                                    tgrad=nothing,
                                    jac=nothing,
                                    jvp=nothing,
                                    vjp=nothing,
                                    jac_prototype=nothing,
                                    sparsity=jac_prototype,
                                    paramjac = nothing,
                                    syms = nothing,
                                    indepsym = nothing,
                                    colorvec = nothing)</code></pre><p>Note that only the functions <code>f_i</code> themselves are required. These functions should be given as <code>f_i!(du,u,h,p,t)</code> or <code>du = f_i(u,h,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling. The histroy function <code>h</code> acts as an interpolator over time, i.e. <code>h(t)</code> with options matching the solution interface, i.e. <code>h(t; save_idxs = 2)</code>.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M_i</code> represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/dae<em>solve/. Must be an AbstractArray or an AbstractSciMLOperator. Should be given as a tuple of mass matrices, i.e. `(M</em>1, M_2)` for the mass matrices of equations 1 and 2 respectively.</li><li><code>analytic(u0,h,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,h,p,t)</code> or dT=tgrad(u,h,p,t): returns <span>$\frac{\partial f(u,p,t)}{\partial t}$</span></li><li><code>jac(J,u,h,p,t)</code> or <code>J=jac(u,h,p,t)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>jvp(Jv,v,u,h,p,t)</code> or <code>Jv=jvp(v,u,h,p,t)</code>: returns the directional derivative<span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,u,h,p,t)</code> or <code>Jv=vjp(v,u,h,p,t)</code>: returns the adjoint derivative<span>$\frac{df}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,u,h,p,t)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the DynamicalDDEFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DiscreteFunction" href="#SciMLBase.DiscreteFunction"><code>SciMLBase.DiscreteFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DiscreteFunction{iip,F,Ta,S,O} &lt;: AbstractDiscreteFunction{iip}</p><p>A representation of an discrete dynamical system <code>f</code>, defined by:</p><p class="math-container">\[u_{n+1} = f(u,p,t_{n+1})\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DiscreteFunction{iip,recompile}(f;
                                analytic=nothing, 
                                syms=nothing)</code></pre><p>Note that only the function <code>f</code> itself is required. This function should be given as <code>f!(du,u,p,t)</code> or <code>du = f(u,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the DiscreteFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L658">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SDEFunction" href="#SciMLBase.SDEFunction"><code>SciMLBase.SDEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SDEFunction{iip,F,G,TMM,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,GG,S,O,TCV} &lt;: AbstractSDEFunction{iip}</p><p>A representation of an SDE function <code>f</code>, defined by:</p><p class="math-container">\[M du = f(u,p,t)dt + g(u,p,t) dW \]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SDEFunction{iip,recompile}(f,g;
                           mass_matrix=I,
                           analytic=nothing,
                           tgrad=nothing,
                           jac=nothing,
                           jvp=nothing,
                           vjp=nothing,
                           ggprime = nothing,
                           jac_prototype=nothing,
                           sparsity=jac_prototype,
                           paramjac = nothing,
                           syms = nothing,
                           indepsym = nothing,
                           colorvec = nothing)</code></pre><p>Note that only the function <code>f</code> itself is required. This function should be given as <code>f!(du,u,p,t)</code> or <code>du = f(u,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M</code> represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/dae_solve/. Must be an AbstractArray or an AbstractSciMLOperator.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,p,t)</code> or dT=tgrad(u,p,t): returns <span>$\frac{\partial f(u,p,t)}{\partial t}$</span></li><li><code>jac(J,u,p,t)</code> or <code>J=jac(u,p,t)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>jvp(Jv,v,u,p,t)</code> or <code>Jv=jvp(v,u,p,t)</code>: returns the directional derivative<span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,u,p,t)</code> or <code>Jv=vjp(v,u,p,t)</code>: returns the adjoint derivative<span>$\frac{df}{du}^\ast v$</span></li><li><code>ggprime(J,u,p,t)</code> or <code>J = ggprime(u,p,t)</code>: returns the Milstein derivative  <span>$\frac{dg(u,p,t)}{du} g(u,p,t)$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the ODEFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SplitSDEFunction" href="#SciMLBase.SplitSDEFunction"><code>SciMLBase.SplitSDEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SplitSDEFunction{iip,F1,F2,G,TMM,C,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,O,TCV} &lt;: AbstractSDEFunction{iip}</p><p>A representation of a split SDE function <code>f</code>, defined by:</p><p class="math-container">\[M \frac{du}{dt} = f_1(u,p,t) + f_2(u,p,t) + g(u,p,t) dW\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p>Generally, for SDE integrators the <code>f_1</code> portion should be considered the &quot;stiff portion of the model&quot; with larger time scale separation, while the <code>f_2</code> portion should be considered the &quot;non-stiff portion&quot;. This interpretation is directly used in integrators like IMEX (implicit-explicit integrators) and exponential integrators.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SplitSDEFunction{iip,recompile}(f1,f2,g;
                 mass_matrix=I,
                 analytic=nothing,
                 tgrad=nothing,
                 jac=nothing,
                 jvp=nothing,
                 vjp=nothing,
                 ggprime = nothing,
                 jac_prototype=nothing,
                 sparsity=jac_prototype,
                 paramjac = nothing,
                 syms = nothing,
                 indepsym = nothing,
                 colorvec = nothing)</code></pre><p>Note that only the function <code>f</code> itself is required. All of the remaining functions are optional for improving or accelerating the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M</code> represented in the SDE function. Can be used to determine that the equation is actually a stochastic differential-algebraic equation (SDAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/sdae_solve/. Must be an AbstractArray or an AbstractSciMLOperator.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,p,t)</code> or dT=tgrad(u,p,t): returns <span>$\frac{\partial f_1(u,p,t)}{\partial t}$</span></li><li><code>jac(J,u,p,t)</code> or <code>J=jac(u,p,t)</code>: returns <span>$\frac{df_1}{du}$</span></li><li><code>jvp(Jv,v,u,p,t)</code> or <code>Jv=jvp(v,u,p,t)</code>: returns the directional derivative<span>$\frac{df_1}{du} v$</span></li><li><code>vjp(Jv,v,u,p,t)</code> or <code>Jv=vjp(v,u,p,t)</code>: returns the adjoint derivative<span>$\frac{df_1}{du}^\ast v$</span></li><li><code>ggprime(J,u,p,t)</code> or <code>J = ggprime(u,p,t)</code>: returns the Milstein derivative  <span>$\frac{dg(u,p,t)}{du} g(u,p,t)$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df_1}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>Note on the Derivative Definition</strong></p><p>The derivatives, such as the Jacobian, are only defined on the <code>f1</code> portion of the split ODE. This is used to treat the <code>f1</code> implicit while keeping the <code>f2</code> portion explicit.</p><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the SplitSDEFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DynamicalSDEFunction" href="#SciMLBase.DynamicalSDEFunction"><code>SciMLBase.DynamicalSDEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DynamicalSDEFunction{iip,F1,F2,G,TMM,C,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,O,TCV} &lt;: AbstractSDEFunction{iip}</p><p>A representation of an SDE function <code>f</code> and <code>g</code>, defined by:</p><p class="math-container">\[M du = f(u,p,t) dt + g(u,p,t) dW_t\]</p><p>as a partitioned ODE:</p><p class="math-container">\[M_1 du = f_1(u,p,t) dt + g(u,p,t) dW_t
M_2 du = f_2(u,p,t) dt + g(u,p,t) dW_t\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DynamicalSDEFunction{iip,recompile}(f1,f2;
                                    mass_matrix=I,
                                    analytic=nothing,
                                    tgrad=nothing,
                                    jac=nothing,
                                    jvp=nothing,
                                    vjp=nothing,
                                    ggprime=nothing,
                                    jac_prototype=nothing,
                                    sparsity=jac_prototype,
                                    paramjac = nothing,
                                    syms = nothing,
                                    indepsym = nothing,
                                    colorvec = nothing)</code></pre><p>Note that only the functions <code>f_i</code> themselves are required. These functions should be given as <code>f_i!(du,u,p,t)</code> or <code>du = f_i(u,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M_i</code> represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/dae<em>solve/. Must be an AbstractArray or an AbstractSciMLOperator. Should be given as a tuple of mass matrices, i.e. `(M</em>1, M_2)` for the mass matrices of equations 1 and 2 respectively.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,p,t)</code> or dT=tgrad(u,p,t): returns <span>$\frac{\partial f(u,p,t)}{\partial t}$</span></li><li><code>jac(J,u,p,t)</code> or <code>J=jac(u,p,t)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>jvp(Jv,v,u,p,t)</code> or <code>Jv=jvp(v,u,p,t)</code>: returns the directional derivative<span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,u,p,t)</code> or <code>Jv=vjp(v,u,p,t)</code>: returns the adjoint derivative<span>$\frac{df}{du}^\ast v$</span></li><li><code>ggprime(J,u,p,t)</code> or <code>J = ggprime(u,p,t)</code>: returns the Milstein derivative  <span>$\frac{dg(u,p,t)}{du} g(u,p,t)$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the DynamicalSDEFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L928">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.RODEFunction" href="#SciMLBase.RODEFunction"><code>SciMLBase.RODEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>RODEFunction{iip,F,TMM,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,O,TCV} &lt;: AbstractRODEFunction{iip}</p><p>A representation of an RODE function <code>f</code>, defined by:</p><p class="math-container">\[M \frac{du}{dt} = f(u,p,t,W)dt\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">RODEFunction{iip,recompile}(f;
                           mass_matrix=I,
                           analytic=nothing,
                           tgrad=nothing,
                           jac=nothing,
                           jvp=nothing,
                           vjp=nothing,
                           jac_prototype=nothing,
                           sparsity=jac_prototype,
                           paramjac = nothing,
                           syms = nothing,
                           indepsym = nothing,
                           colorvec = nothing)</code></pre><p>Note that only the function <code>f</code> itself is required. This function should be given as <code>f!(du,u,p,t)</code> or <code>du = f(u,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M</code> represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/dae_solve/. Must be an AbstractArray or an AbstractSciMLOperator.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,p,t)</code> or dT=tgrad(u,p,t): returns <span>$\frac{\partial f(u,p,t)}{\partial t}$</span></li><li><code>jac(J,u,p,t)</code> or <code>J=jac(u,p,t)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>jvp(Jv,v,u,p,t)</code> or <code>Jv=jvp(v,u,p,t)</code>: returns the directional derivative<span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,u,p,t)</code> or <code>Jv=vjp(v,u,p,t)</code>: returns the adjoint derivative<span>$\frac{df}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the RODEFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L1046">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.DAEFunction" href="#SciMLBase.DAEFunction"><code>SciMLBase.DAEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DAEFunction{iip,F,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,O,TCV} &lt;: AbstractDAEFunction{iip}</p><p>A representation of an implicit DAE function <code>f</code>, defined by:</p><p class="math-container">\[0 = f(\frac{du}{dt},u,p,t)\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DAEFunction{iip,recompile}(f;
                           analytic=nothing,
                           jac=nothing,
                           jvp=nothing,
                           vjp=nothing,
                           jac_prototype=nothing,
                           sparsity=jac_prototype,
                           syms = nothing,
                           indepsym = nothing,
                           colorvec = nothing)</code></pre><p>Note that only the function <code>f</code> itself is required. This function should be given as <code>f!(out,du,u,p,t)</code> or <code>out = f(du,u,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>jac(J,du,u,p,gamma,t)</code> or <code>J=jac(du,u,p,gamma,t)</code>: returns the implicit DAE Jacobian defined as <span>$gamma \frac{dG}{d(du)} + \frac{dG}{du}$</span></li><li><code>jvp(Jv,v,du,u,p,gamma,t)</code> or <code>Jv=jvp(v,du,u,p,gamma,t)</code>: returns the directional  derivative<span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,du,u,p,gamma,t)</code> or <code>Jv=vjp(v,du,u,p,gamma,t)</code>: returns the adjoint  derivative<span>$\frac{df}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the DAEFunction type directly match the names of the inputs.</p><p><strong>Examples</strong></p><p><strong>Declaring Explicit Jacobians for DAEs</strong></p><p>For fully implicit ODEs (<code>DAEProblem</code>s), a slightly different Jacobian function is necessary. For the DAE</p><p class="math-container">\[G(du,u,p,t) = res\]</p><p>The Jacobian should be given in the form <code>gamma*dG/d(du) + dG/du</code> where <code>gamma</code> is given by the solver. This means that the signature is:</p><pre><code class="language-julia hljs">f(J,du,u,p,gamma,t)</code></pre><p>For example, for the equation</p><pre><code class="language-julia hljs">function testjac(res,du,u,p,t)
  res[1] = du[1] - 2.0 * u[1] + 1.2 * u[1]*u[2]
  res[2] = du[2] -3 * u[2] - u[1]*u[2]
end</code></pre><p>we would define the Jacobian as:</p><pre><code class="language-julia hljs">function testjac(J,du,u,p,gamma,t)
  J[1,1] = gamma - 2.0 + 1.2 * u[2]
  J[1,2] = 1.2 * u[1]
  J[2,1] = - 1 * u[2]
  J[2,2] = gamma - 3 - u[1]
  nothing
end</code></pre><p><strong>Symbolically Generating the Functions</strong></p><p>See the <code>modelingtoolkitize</code> function from <a href="https://github.com/JuliaDiffEq/ModelingToolkit.jl">ModelingToolkit.jl</a> for automatically symbolically generating the Jacobian and more from the  numerically-defined functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L1148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.SDDEFunction" href="#SciMLBase.SDDEFunction"><code>SciMLBase.SDDEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SDDEFunction{iip,F,G,TMM,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,GG,S,O,TCV} &lt;: AbstractSDDEFunction{iip}</p><p>A representation of a SDDE function <code>f</code>, defined by:</p><p class="math-container">\[M du = f(u,h,p,t) dt + g(u,h,p,t) dW_t\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SDDEFunction{iip,recompile}(f,g;
                 mass_matrix=I,
                 analytic=nothing,
                 tgrad=nothing,
                 jac=nothing,
                 jvp=nothing,
                 vjp=nothing,
                 jac_prototype=nothing,
                 sparsity=jac_prototype,
                 paramjac = nothing,
                 syms = nothing,
                 indepsym = nothing,
                 colorvec = nothing)</code></pre><p>Note that only the function <code>f</code> itself is required. This function should be given as <code>f!(du,u,h,p,t)</code> or <code>du = f(u,h,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling. The histroy function <code>h</code> acts as an interpolator over time, i.e. <code>h(t)</code> with options matching the solution interface, i.e. <code>h(t; save_idxs = 2)</code>.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M</code> represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/dae_solve/. Must be an AbstractArray or an AbstractSciMLOperator.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,h,p,t)</code> or dT=tgrad(u,p,t): returns <span>$\frac{\partial f(u,p,t)}{\partial t}$</span></li><li><code>jac(J,u,h,p,t)</code> or <code>J=jac(u,p,t)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>jvp(Jv,v,h,u,p,t)</code> or <code>Jv=jvp(v,u,p,t)</code>: returns the directional derivative<span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,h,u,p,t)</code> or <code>Jv=vjp(v,u,p,t)</code>: returns the adjoint derivative<span>$\frac{df}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,h,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the DDEFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L1290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.NonlinearFunction" href="#SciMLBase.NonlinearFunction"><code>SciMLBase.NonlinearFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NonlinearFunction{iip,F,TMM,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,O,TCV} &lt;: AbstractNonlinearFunction{iip}</p><p>A representation of an nonlinear system of equations <code>f</code>, defined by:</p><p class="math-container">\[0 = f(u,p)\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">NonlinearFunction{iip,recompile}(f;
                           analytic=nothing,
                           jac=nothing,
                           jvp=nothing,
                           vjp=nothing,
                           jac_prototype=nothing,
                           sparsity=jac_prototype,
                           paramjac = nothing,
                           syms = nothing,
                           indepsym = nothing,
                           colorvec = nothing)</code></pre><p>Note that only the function <code>f</code> itself is required. This function should be given as <code>f!(du,u,p)</code> or <code>du = f(u,p)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating  the usage of <code>f</code>. These include:</p><ul><li><code>analytic(u0,p)</code>: used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>jac(J,u,p)</code> or <code>J=jac(u,p)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>jvp(Jv,v,u,p)</code> or <code>Jv=jvp(v,u,p)</code>: returns the directional derivative<span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,u,p)</code> or <code>Jv=vjp(v,u,p)</code>: returns the adjoint derivative<span>$\frac{df}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,u,p)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u0 = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>indepsym</code>: the canonical naming for the independent variable. Defaults to nothing, which internally uses <code>t</code> as the representation in any plots.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the NonlinearFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L1396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.OptimizationFunction" href="#SciMLBase.OptimizationFunction"><code>SciMLBase.OptimizationFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>OptimizationFunction{iip,AD,F,G,H,HV,C,CJ,CH,HP,CJP,CHP,S,HCV,CJCV,CHCV} &lt;: AbstractOptimizationFunction{iip}</p><p>A representation of an optimization of an objective function <code>f</code>, defined by:</p><p class="math-container">\[min_{u} f(u,p)\]</p><p>and all of its related functions, such as the gradient of <code>f</code>, its Hessian,  and more. For all cases, <code>u</code> is the state and <code>p</code> are the parameters.</p><p><strong>Constructor</strong></p><p>OptimizationFunction{iip}(f,adtype::AbstractADType=NoAD();                           grad=nothing,hess=nothing,hv=nothing,                           cons=nothing, cons<em>j=nothing,cons</em>h=nothing,                           hess<em>prototype=nothing,cons</em>jac<em>prototype=nothing,                           cons</em>hess<em>prototype = nothing,                           syms = nothing, hess</em>colorvec = nothing,                           cons<em>jac</em>colorvec = nothing,                           cons<em>hess</em>colorvec = nothing)</p><ul><li><code>adtype</code>: see the section &quot;Defining Optimization Functions via AD&quot;</li><li><code>grad(G,u,p)</code> or <code>G=grad(u,p)</code>: the gradient of <code>f</code> with respect to <code>u</code></li><li><code>hess(H,u,p)</code> or <code>H=hess(u,p)</code>: the Hessian of <code>f</code> with respect to <code>u</code></li><li><code>hv(Hv,u,v,p)</code> or <code>Hv=hv(u,v,p)</code>: the Hessian-vector product <span>$rac{d^2 f}{du^2} v$</span>.</li><li><code>cons(res,x,p)</code> or <code>res=cons(x,p)</code>: the equality constraints vector, where the constraints are satisfied when <code>res = 0</code>.</li><li><code>cons_j(res,x,p)</code> or <code>res=cons_j(x,p)</code>: the Jacobian of the equality constraints.</li><li><code>cons_h(res,x,p)</code> or <code>res=cons_h(x,p)</code>: the Hessian of the equality constratins, provided as and array of Hessians with <code>res[i]</code> being the Hessian with respect to the <code>i</code>th output on <code>cons</code>.</li><li><code>paramjac(pJ,u,p)</code>: returns the parameter Jacobian <span>$rac{df}{dp}$</span>.</li><li><code>hess_prototype</code>: a prototype matrix matching the type that matches the Hessian. For example, if the Hessian is tridiagonal, then an appropriately sized <code>Hessian</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Hessian. The default is <code>nothing</code>, which means a dense Hessian.</li><li><code>cons_jac_prototype</code>: a prototype matrix matching the type that matches the constraint Jacobian.  The default is <code>nothing</code>, which means a dense constraint Jacobian.</li><li><code>cons_hess_prototype</code>: a prototype matrix matching the type that matches the constraint Hessian. This is defined as an array of matrices, where <code>hess[i]</code> is the Hessian w.r.t. the <code>i</code>th output. For example, if the Hessian is sparse, then <code>hess</code> is a <code>Vector{SparseMatrixCSC}</code>. The default is <code>nothing</code>, which means a dense constraint Hessian.  </li><li><code>syms</code>: the symbol names for the elements of the equation. This should match <code>u0</code> in size. For example, if <code>u = [0.0,1.0]</code> and <code>syms = [:x, :y]</code>, this will apply a canonical naming to the values, allowing <code>sol[:x]</code> in the solution and automatically naming values in plots.</li><li><code>hess_colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>hess_prototype</code>. This specializes the Hessian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li><li><code>cons_jac_colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>cons_jac_prototype</code>.</li><li><code>cons_hess_colorvec</code>: an array of color vector according to the SparseDiffTools.jl definition for  the sparsity pattern of the <code>cons_hess_prototype</code>.</li></ul><p><strong>Defining Optimization Functions Via AD</strong></p><p>While using the keyword arguments gives the user control over defining all of the possible functions, the simplest way to handle the generation of an <code>OptimizationFunction</code> is by specifying an AD type. By doing so, this will automatically fill in all of the extra functions. For example,</p><pre><code class="language-julia hljs">OptimizationFunction(f,AutoZygote())</code></pre><p>will use <a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a> to define all of the necessary functions. Note that if any functions are defined directly, the auto-AD definition does not overwrite the user&#39;s choice.</p><p>Each of the AD-based constructors are documented separately via their own dispatches.</p><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>recompile: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the OptimizationFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/a8a8f4653dfb29fd20eb1e6a74218650cf0a2ce3/src/scimlfunctions.jl#L1485-L1572">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Problems/">« SciMLProblems</a><a class="docs-footer-nextpage" href="../Algorithms/">SciMLAlgorithms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Monday 30 May 2022 16:31">Monday 30 May 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
