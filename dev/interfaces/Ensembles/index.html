<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel Ensemble Simulations Interface · SciMLBase.jl</title><meta name="title" content="Parallel Ensemble Simulations Interface · SciMLBase.jl"/><meta property="og:title" content="Parallel Ensemble Simulations Interface · SciMLBase.jl"/><meta property="twitter:title" content="Parallel Ensemble Simulations Interface · SciMLBase.jl"/><meta name="description" content="Documentation for SciMLBase.jl."/><meta property="og:description" content="Documentation for SciMLBase.jl."/><meta property="twitter:description" content="Documentation for SciMLBase.jl."/><meta property="og:url" content="https://docs.sciml.ai/SciMLBase/stable/interfaces/Ensembles/"/><meta property="twitter:url" content="https://docs.sciml.ai/SciMLBase/stable/interfaces/Ensembles/"/><link rel="canonical" href="https://docs.sciml.ai/SciMLBase/stable/interfaces/Ensembles/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SciMLBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SciMLBase.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../Array_and_Number/">SciML Container (Array) and Number Interfaces</a></li><li><a class="tocitem" href="../Problems/">SciMLProblems</a></li><li><a class="tocitem" href="../SciMLFunctions/">SciMLFunctions (Jacobians, Sparsity, Etc.)</a></li><li><a class="tocitem" href="../Algorithms/">SciMLAlgorithms</a></li><li><a class="tocitem" href="../Solutions/">SciMLSolutions</a></li><li><a class="tocitem" href="../Init_Solve/">The SciML init and solve Functions</a></li><li class="is-active"><a class="tocitem" href>Parallel Ensemble Simulations Interface</a><ul class="internal"><li><a class="tocitem" href="#Performing-an-Ensemble-Simulation"><span>Performing an Ensemble Simulation</span></a></li><li><a class="tocitem" href="#Analyzing-an-Ensemble-Experiment"><span>Analyzing an Ensemble Experiment</span></a></li><li><a class="tocitem" href="#Example-1:-Solving-an-ODE-With-Different-Initial-Conditions"><span>Example 1: Solving an ODE With Different Initial Conditions</span></a></li><li><a class="tocitem" href="#Example-2:-Solving-an-SDE-with-Different-Parameters"><span>Example 2: Solving an SDE with Different Parameters</span></a></li><li><a class="tocitem" href="#Example-3:-Using-the-Reduction-to-Halt-When-Estimator-is-Within-Tolerance"><span>Example 3: Using the Reduction to Halt When Estimator is Within Tolerance</span></a></li><li><a class="tocitem" href="#Example-4:-Using-the-Analysis-Tools"><span>Example 4: Using the Analysis Tools</span></a></li></ul></li><li><a class="tocitem" href="../Common_Keywords/">Common Keyword Arguments</a></li><li><a class="tocitem" href="../Differentiation/">Automatic Differentiation and Sensitivity Algorithms (Adjoints)</a></li><li><a class="tocitem" href="../PDE/">The PDE Definition Interface</a></li></ul></li><li><span class="tocitem">Fundamentals</span><ul><li><a class="tocitem" href="../../fundamentals/FAQ/">Frequently Asked Questions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Interfaces</a></li><li class="is-active"><a href>Parallel Ensemble Simulations Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parallel Ensemble Simulations Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/SciMLBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/SciMLBase.jl/blob/master/docs/src/interfaces/Ensembles.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ensemble"><a class="docs-heading-anchor" href="#ensemble">Parallel Ensemble Simulations Interface</a><a id="ensemble-1"></a><a class="docs-heading-anchor-permalink" href="#ensemble" title="Permalink"></a></h1><p>Performing Monte Carlo simulations, solving with a predetermined set of initial conditions, and GPU-parallelizing a parameter search all fall under the ensemble simulation interface. This interface allows one to declare a template AbstractSciMLProblem to parallelize, tweak the template in <code>trajectories</code> for many trajectories, solve each in parallel batches, reduce the solutions down to specific answers, and compute summary statistics on the results.</p><h2 id="Performing-an-Ensemble-Simulation"><a class="docs-heading-anchor" href="#Performing-an-Ensemble-Simulation">Performing an Ensemble Simulation</a><a id="Performing-an-Ensemble-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-an-Ensemble-Simulation" title="Permalink"></a></h2><h3 id="Building-a-Problem"><a class="docs-heading-anchor" href="#Building-a-Problem">Building a Problem</a><a id="Building-a-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-Problem" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleProblem"><a class="docstring-binding" href="#SciMLBase.EnsembleProblem"><code>SciMLBase.EnsembleProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct EnsembleProblem{T, T2, T3, T4, T5} &lt;: SciMLBase.AbstractEnsembleProblem</code></pre><p>Defines a structure to manage an ensemble (batch) of problems. Each field controls how the ensemble behaves during simulation.</p><p><strong>Arguments</strong></p><ul><li><code>prob</code>: The original base problem to replicate or modify.</li><li><code>prob_func</code>: A function that defines how to generate each subproblem.</li><li><code>output_func</code>: A function to post-process each individual simulation result.</li><li><code>reduction</code>: A function to combine results from all simulations.</li><li><code>u_init</code>: The initial container used to accumulate the results.</li><li><code>safetycopy</code>: Whether to copy the problem when creating subproblems (to avoid unintended modifications).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_problems.jl#L98">source</a></section></details></article><h3 id="Solving-the-Problem"><a class="docs-heading-anchor" href="#Solving-the-Problem">Solving the Problem</a><a id="Solving-the-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-Problem" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SciMLBase.__solve-Tuple{SciMLBase.AbstractEnsembleProblem, Any, SciMLBase.BasicEnsembleAlgorithm}"><a class="docstring-binding" href="#SciMLBase.__solve-Tuple{SciMLBase.AbstractEnsembleProblem, Any, SciMLBase.BasicEnsembleAlgorithm}"><code>SciMLBase.__solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sim = solve(enprob, alg, ensemblealg = EnsembleThreads(), kwargs...)</code></pre><p>Solves the ensemble problem <code>enprob</code> with the algorithm <code>alg</code> using the ensembler <code>ensemblealg</code>.</p><p>The keyword arguments take in the arguments for the common solver interface and will pass them to the solver. The <code>ensemblealg</code> is optional, and will default to <code>EnsembleThreads()</code>. The special keyword arguments to note are:</p><ul><li><code>trajectories</code>: The number of simulations to run. This argument is required.</li><li><code>batch_size</code> : The size of the batches on which the reductions are applies. Defaults to <code>trajectories</code>.</li><li><code>pmap_batch_size</code>: The size of the <code>pmap</code> batches. Default is <code>batch_size÷100 &gt; 0 ? batch_size÷100 : 1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/basic_ensemble_solve.jl#L149-L163">source</a></section></details></article><h3 id="EnsembleAlgorithms"><a class="docs-heading-anchor" href="#EnsembleAlgorithms">EnsembleAlgorithms</a><a id="EnsembleAlgorithms-1"></a><a class="docs-heading-anchor-permalink" href="#EnsembleAlgorithms" title="Permalink"></a></h3><p>The choice of ensemble algorithm allows for control over how the multiple trajectories are handled. Currently, the ensemble algorithm types are:</p><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleSerial"><a class="docstring-binding" href="#SciMLBase.EnsembleSerial"><code>SciMLBase.EnsembleSerial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct EnsembleSerial &lt;: SciMLBase.BasicEnsembleAlgorithm</code></pre><p>Basic ensemble solver which uses no parallelism and runs the problems in serial</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/basic_ensemble_solve.jl#L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleThreads"><a class="docstring-binding" href="#SciMLBase.EnsembleThreads"><code>SciMLBase.EnsembleThreads</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct EnsembleThreads &lt;: SciMLBase.BasicEnsembleAlgorithm</code></pre><p>The default. This uses multithreading. It&#39;s local (single computer, shared memory) parallelism only. Lowest parallelism overhead for small problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/basic_ensemble_solve.jl#L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleDistributed"><a class="docstring-binding" href="#SciMLBase.EnsembleDistributed"><code>SciMLBase.EnsembleDistributed</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct EnsembleDistributed &lt;: SciMLBase.BasicEnsembleAlgorithm</code></pre><p>Uses <code>pmap</code> internally. It will use as many processors as you have Julia processes. To add more processes, use <code>addprocs(n)</code>. These processes can be placed onto multiple different machines in order to paralleize across an entire cluster via passwordless SSH. See Julia&#39;s documentation for more details.</p><p>Recommended for the case when each trajectory calculation isn&#39;t “too quick” (at least about a millisecond each?), where the calculations of a given problem allocate memory, or when you have a very large ensemble. This can be true even on a single shared memory system because distributed process use separate garbage collectors and thus can be even faster than EnsembleThreads if the computation is complex enough.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/basic_ensemble_solve.jl#L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleSplitThreads"><a class="docstring-binding" href="#SciMLBase.EnsembleSplitThreads"><code>SciMLBase.EnsembleSplitThreads</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct EnsembleSplitThreads &lt;: SciMLBase.BasicEnsembleAlgorithm</code></pre><p>A mixture of distributed computing with threading. The optimal version of this is to have a process on each node of a computer and then multithread on each system. However, this ensembler will simply use the node setup provided by the Julia Distributed processes, and thus it is recommended that you setup the processes in this fashion before using this ensembler. See Julia&#39;s Distributed documentation for more information</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/basic_ensemble_solve.jl#L39">source</a></section></details></article><h4 id="DiffEq-Only-(ODEProblem,-SDEProblem)"><a class="docs-heading-anchor" href="#DiffEq-Only-(ODEProblem,-SDEProblem)">DiffEq Only (ODEProblem, SDEProblem)</a><a id="DiffEq-Only-(ODEProblem,-SDEProblem)-1"></a><a class="docs-heading-anchor-permalink" href="#DiffEq-Only-(ODEProblem,-SDEProblem)" title="Permalink"></a></h4><table><tr><th style="text-align: left">GPU Manufacturer</th><th style="text-align: left">GPU Kernel Language</th><th style="text-align: left">Julia Support Package</th><th style="text-align: left">Backend Type</th></tr><tr><td style="text-align: left">NVIDIA</td><td style="text-align: left">CUDA</td><td style="text-align: left"><a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a></td><td style="text-align: left"><code>CUDA.CUDABackend()</code></td></tr><tr><td style="text-align: left">AMD</td><td style="text-align: left">ROCm</td><td style="text-align: left"><a href="https://github.com/JuliaGPU/AMDGPU.jl">AMDGPU.jl</a></td><td style="text-align: left"><code>AMDGPU.ROCBackend()</code></td></tr><tr><td style="text-align: left">Intel</td><td style="text-align: left">OneAPI</td><td style="text-align: left"><a href="https://github.com/JuliaGPU/oneAPI.jl">OneAPI.jl</a></td><td style="text-align: left"><code>oneAPI.oneAPIBackend()</code></td></tr><tr><td style="text-align: left">Apple (M-Series)</td><td style="text-align: left">Metal</td><td style="text-align: left"><a href="https://github.com/JuliaGPU/Metal.jl">Metal.jl</a></td><td style="text-align: left"><code>Metal.MetalBackend()</code></td></tr></table><ul><li><code>EnsembleGPUArray()</code> - Requires installing and <code>using DiffEqGPU</code>. This uses a GPU for computing the ensemble with hyperparallelism. It will automatically recompile your Julia functions to the GPU. A standard GPU sees a 5x performance increase over a 16 core Xeon CPU. However, there are limitations on what functions can auto-compile in this fashion, please see <a href="https://docs.sciml.ai/DiffEqGPU/stable/">DiffEqGPU for more details</a></li><li><code>EnsembleGPUKernel()</code> - Requires installing and <code>using DiffEqGPU</code>. This uses a GPU for computing the ensemble with hyperparallelism by building a custom GPU kernel. This can have drastically less overhead (for example, achieving 15x accelerating against Jax and PyTorch, see <a href="https://www.sciencedirect.com/science/article/abs/pii/S0045782523007156">this paper for more details</a>) but has limitations on what kinds of problems are compatible. See <a href="https://docs.sciml.ai/DiffEqGPU/stable/">DiffEqGPU for more details</a></li></ul><h3 id="Choosing-an-Ensembler"><a class="docs-heading-anchor" href="#Choosing-an-Ensembler">Choosing an Ensembler</a><a id="Choosing-an-Ensembler-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-an-Ensembler" title="Permalink"></a></h3><p>For example, <code>EnsembleThreads()</code> is invoked by:</p><pre><code class="language-julia hljs">solve(ensembleprob, alg, EnsembleThreads(); trajectories = 1000)</code></pre><h3 id="Solution-Type"><a class="docs-heading-anchor" href="#Solution-Type">Solution Type</a><a id="Solution-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-Type" title="Permalink"></a></h3><p>The resulting type is a <code>EnsembleSimulation</code>, which includes the array of solutions.</p><h3 id="Plot-Recipe"><a class="docs-heading-anchor" href="#Plot-Recipe">Plot Recipe</a><a id="Plot-Recipe-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Recipe" title="Permalink"></a></h3><p>There is a plot recipe for a <code>AbstractEnsembleSimulation</code> which composes all of the plot recipes for the component solutions. The keyword arguments are passed along. A useful argument to use is <code>linealpha</code> which will change the transparency of the plots. An additional argument is <code>idxs</code> which allows you to choose which components of the solution to plot. For example, if the differential equation is a vector of 9 values, <code>idxs=1:2:9</code> will plot only the solutions of the odd components. Another additional argument is <code>zcolors</code> (an alias of <code>marker_z</code>) which allows you to pass a <code>zcolor</code> for each series. For details about <code>zcolor</code> see the <a href="https://docs.juliaplots.org/stable/attributes/">Series documentation for Plots.jl</a>.</p><h2 id="Analyzing-an-Ensemble-Experiment"><a class="docs-heading-anchor" href="#Analyzing-an-Ensemble-Experiment">Analyzing an Ensemble Experiment</a><a id="Analyzing-an-Ensemble-Experiment-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-an-Ensemble-Experiment" title="Permalink"></a></h2><p>Analysis tools are included for generating summary statistics and summary plots for a <code>EnsembleSimulation</code>.</p><p>To use this functionality, import the analysis module via:</p><pre><code class="language-julia hljs">using SciMLBase.EnsembleAnalysis</code></pre><h3 id="Time-steps-vs-time-points"><a class="docs-heading-anchor" href="#Time-steps-vs-time-points">Time steps vs time points</a><a id="Time-steps-vs-time-points-1"></a><a class="docs-heading-anchor-permalink" href="#Time-steps-vs-time-points" title="Permalink"></a></h3><p>For the summary statistics, there are two types. You can either summarize by time steps or by time points. Summarizing by time steps assumes that the time steps are all the same time point, i.e. the integrator used a fixed <code>dt</code> or the values were saved using <code>saveat</code>. Summarizing by time points requires interpolating the solution.</p><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.get_timestep"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.get_timestep"><code>SciMLBase.EnsembleAnalysis.get_timestep</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_timestep(sim, i)
</code></pre><p>Returns an iterator of each simulation at time step i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.get_timepoint"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.get_timepoint"><code>SciMLBase.EnsembleAnalysis.get_timepoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_timepoint(sim, t)
</code></pre><p>Returns an iterator of each simulation at time point t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.componentwise_vectors_timestep"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.componentwise_vectors_timestep"><code>SciMLBase.EnsembleAnalysis.componentwise_vectors_timestep</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">componentwise_vectors_timestep(sim, i)
</code></pre><p>Returns a vector of each simulation at time step i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.componentwise_vectors_timepoint"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.componentwise_vectors_timepoint"><code>SciMLBase.EnsembleAnalysis.componentwise_vectors_timepoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">componentwise_vectors_timepoint(sim, t)
</code></pre><p>Returns a vector of each simulation at time point t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L35">source</a></section></details></article><h3 id="Summary-Statistics-Functions"><a class="docs-heading-anchor" href="#Summary-Statistics-Functions">Summary Statistics Functions</a><a id="Summary-Statistics-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-Statistics-Functions" title="Permalink"></a></h3><h4 id="Single-Time-Statistics"><a class="docs-heading-anchor" href="#Single-Time-Statistics">Single Time Statistics</a><a id="Single-Time-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Time-Statistics" title="Permalink"></a></h4><p>The available functions for time steps are:</p><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timestep_mean"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timestep_mean"><code>SciMLBase.EnsembleAnalysis.timestep_mean</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timestep_mean(sim, i)
</code></pre><p>Computes the mean of each component at time step i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timestep_median"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timestep_median"><code>SciMLBase.EnsembleAnalysis.timestep_median</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timestep_median(sim, i)
</code></pre><p>Computes the median of each component at time step i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timestep_quantile"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timestep_quantile"><code>SciMLBase.EnsembleAnalysis.timestep_quantile</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timestep_quantile(sim, q, i)
</code></pre><p>Computes the quantile q of each component at time step i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timestep_meanvar"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timestep_meanvar"><code>SciMLBase.EnsembleAnalysis.timestep_meanvar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timestep_meanvar(sim, i)
</code></pre><p>Computes the mean and variance of each component at time step i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timestep_meancov"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timestep_meancov"><code>SciMLBase.EnsembleAnalysis.timestep_meancov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timestep_meancov(sim, i, j)
</code></pre><p>Computes the mean at i and j, and the covariance, for each component</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timestep_meancor"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timestep_meancor"><code>SciMLBase.EnsembleAnalysis.timestep_meancor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timestep_meancor(sim, i, j)
</code></pre><p>Computes the mean at i and j, and the correlation, for each component</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timestep_weighted_meancov"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timestep_weighted_meancov"><code>SciMLBase.EnsembleAnalysis.timestep_weighted_meancov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timestep_weighted_meancov(sim, W, i, j)
</code></pre><p>Computes the mean at i and j, and the weighted covariance W, for each component</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L116">source</a></section></details></article><p>The available functions for time points are:</p><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timepoint_mean"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timepoint_mean"><code>SciMLBase.EnsembleAnalysis.timepoint_mean</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timepoint_mean(sim, t)
</code></pre><p>Computes the mean of each component at time t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timepoint_median"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timepoint_median"><code>SciMLBase.EnsembleAnalysis.timepoint_median</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timepoint_median(sim, t)
</code></pre><p>Computes the median of each component at time t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timepoint_quantile"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timepoint_quantile"><code>SciMLBase.EnsembleAnalysis.timepoint_quantile</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timepoint_quantile(sim, q, t)
</code></pre><p>Computes the quantile q of each component at time t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timepoint_meanvar"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timepoint_meanvar"><code>SciMLBase.EnsembleAnalysis.timepoint_meanvar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timepoint_meanvar(sim, t)
</code></pre><p>Computes the mean and variance of each component at time t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timepoint_meancov"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timepoint_meancov"><code>SciMLBase.EnsembleAnalysis.timepoint_meancov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timepoint_meancov(sim, t1, t2)
</code></pre><p>Computes the mean at t1 and t2, the covariance, for each component</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timepoint_meancor"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timepoint_meancor"><code>SciMLBase.EnsembleAnalysis.timepoint_meancor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timepoint_meancor(sim, t1, t2)
</code></pre><p>Computes the mean at t1 and t2, the correlation, for each component</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timepoint_weighted_meancov"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timepoint_weighted_meancov"><code>SciMLBase.EnsembleAnalysis.timepoint_weighted_meancov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timepoint_weighted_meancov(sim, W, t1, t2)
</code></pre><p>Computes the mean at t1 and t2, the weighted covariance W, for each component</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L271">source</a></section></details></article><h4 id="Full-Timeseries-Statistics"><a class="docs-heading-anchor" href="#Full-Timeseries-Statistics">Full Timeseries Statistics</a><a id="Full-Timeseries-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Timeseries-Statistics" title="Permalink"></a></h4><p>Additionally, the following functions are provided for analyzing the full timeseries. The <code>mean</code> and <code>meanvar</code> versions return a <code>DiffEqArray</code> which can be directly plotted. The <code>meancov</code> and <code>meancor</code> return a matrix of tuples, where the tuples are the <code>(mean_t1,mean_t2,cov or cor)</code>.</p><p>The available functions for the time steps are:</p><div class="admonition is-warning" id="Missing-docstring.-33df2e15298bd50e"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-33df2e15298bd50e" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>timeseries_steps_mean</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-2e1b87a68a92f0ac"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-2e1b87a68a92f0ac" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>timeseries_steps_median</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-b528eabfcda6b469"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-b528eabfcda6b469" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>timeseries_steps_quantile</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-4ef3b98e36948626"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-4ef3b98e36948626" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>timeseries_steps_meanvar</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-516cdcebefd7606a"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-516cdcebefd7606a" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>timeseries_steps_meancov</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-4df1df463019c0d8"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-4df1df463019c0d8" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>timeseries_steps_meancor</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-7015b34c2c3d47db"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-7015b34c2c3d47db" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>timeseries_steps_weighted_meancov</code>. Check Documenter&#39;s build log for details.</p></div></div><p>The available functions for the time points are:</p><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timeseries_point_mean"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timeseries_point_mean"><code>SciMLBase.EnsembleAnalysis.timeseries_point_mean</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timeseries_point_mean(sim, ts)
</code></pre><p>Computes the mean at each time point in ts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timeseries_point_median"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timeseries_point_median"><code>SciMLBase.EnsembleAnalysis.timeseries_point_median</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timeseries_point_median(sim, ts)
</code></pre><p>Computes the median at each time point in ts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timeseries_point_quantile"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timeseries_point_quantile"><code>SciMLBase.EnsembleAnalysis.timeseries_point_quantile</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timeseries_point_quantile(sim, q, ts)
</code></pre><p>Computes the quantile q at each time point in ts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L318">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timeseries_point_meanvar"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timeseries_point_meanvar"><code>SciMLBase.EnsembleAnalysis.timeseries_point_meanvar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timeseries_point_meanvar(sim, ts)
</code></pre><p>Computes the mean and variance at each time point in ts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timeseries_point_meancov"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timeseries_point_meancov"><code>SciMLBase.EnsembleAnalysis.timeseries_point_meancov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timeseries_point_meancov(sim, ts)
</code></pre><p>Computes the covariance matrix and means at each time point in ts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L344">source</a></section><section><div><pre><code class="language-julia hljs">timeseries_point_meancov(sim, ts1, ts2)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L353">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timeseries_point_meancor"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timeseries_point_meancor"><code>SciMLBase.EnsembleAnalysis.timeseries_point_meancor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timeseries_point_meancor(sim, ts)
</code></pre><p>Computes the correlation matrix and means at each time point in ts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L361">source</a></section><section><div><pre><code class="language-julia hljs">timeseries_point_meancor(sim, ts1, ts2)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleAnalysis.timeseries_point_weighted_meancov"><a class="docstring-binding" href="#SciMLBase.EnsembleAnalysis.timeseries_point_weighted_meancov"><code>SciMLBase.EnsembleAnalysis.timeseries_point_weighted_meancov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timeseries_point_weighted_meancov(sim, W, ts)
</code></pre><p>Computes the weighted covariance matrix and means at each time point in ts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L378">source</a></section><section><div><pre><code class="language-julia hljs">timeseries_point_weighted_meancov(sim, W, ts1, ts2)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_analysis.jl#L387">source</a></section></details></article><h3 id="EnsembleSummary"><a class="docs-heading-anchor" href="#EnsembleSummary">EnsembleSummary</a><a id="EnsembleSummary-1"></a><a class="docs-heading-anchor-permalink" href="#EnsembleSummary" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SciMLBase.EnsembleSummary"><a class="docstring-binding" href="#SciMLBase.EnsembleSummary"><code>SciMLBase.EnsembleSummary</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct EnsembleSummary{T, N, Tt, S, S2, S3, S4, S5} &lt;: SciMLBase.AbstractEnsembleSolution{T, N, S}</code></pre><p>The <code>EnsembleSummary</code> type is included to help with analyzing the general summary statistics. Two constructors are provided:</p><pre><code class="language-julia hljs">EnsembleSummary(sim; quantiles = [0.05, 0.95])
EnsembleSummary(sim, ts; quantiles = [0.05, 0.95])</code></pre><p>The first produces a <code>(mean,var)</code> summary at each time step. As with the summary statistics, this assumes that the time steps are all the same. The second produces a <code>(mean,var)</code> summary at each time point <code>t</code> in <code>ts</code>. This requires the ability to interpolate the solution. Quantile is used to determine the <code>qlow</code> and <code>qhigh</code> quantiles at each timepoint. It defaults to the 5% and 95% quantiles.</p><p><strong>Plot Recipe</strong></p><p>The <code>EnsembleSummary</code> comes with a plot recipe for visualizing the summary statistics. The extra keyword arguments are:</p><ul><li><code>idxs</code>: the solution components to plot. Defaults to plotting all components.</li><li><code>error_style</code>: The style for plotting the error. Defaults to <code>ribbon</code>. Other choices are <code>:bars</code> for error bars and <code>:none</code> for no error bars.</li><li><code>ci_type</code> : Defaults to <code>:quantile</code> which has <code>(qlow,qhigh)</code> quantiles whose limits were determined when constructing the <code>EnsembleSummary</code>. Gaussian CI <code>1.96*(standard error of the mean)</code> can be set using <code>ci_type=:SEM</code>.</li></ul><p>One useful argument is <code>fillalpha</code> which controls the transparency of the ribbon around the mean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/0d13577347d01e9583254acccfd1b67ab039d47e/src/ensemble/ensemble_solutions.jl#L66">source</a></section></details></article><h2 id="Example-1:-Solving-an-ODE-With-Different-Initial-Conditions"><a class="docs-heading-anchor" href="#Example-1:-Solving-an-ODE-With-Different-Initial-Conditions">Example 1: Solving an ODE With Different Initial Conditions</a><a id="Example-1:-Solving-an-ODE-With-Different-Initial-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Solving-an-ODE-With-Different-Initial-Conditions" title="Permalink"></a></h2><h3 id="Random-Initial-Conditions"><a class="docs-heading-anchor" href="#Random-Initial-Conditions">Random Initial Conditions</a><a id="Random-Initial-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Initial-Conditions" title="Permalink"></a></h3><p>Let&#39;s test the sensitivity of the linear ODE to its initial condition. To do this, we would like to solve the linear ODE 100 times and plot what the trajectories look like. Let&#39;s start by opening up some extra processes so that way the computation will be parallelized. Here we will choose to use distributed parallelism, which means that the required functions must be made available to all processes. This can be achieved with <a href="https://docs.julialang.org/en/v1.2/stdlib/Distributed/#Distributed.@everywhere"><code>@everywhere</code> macro</a>:</p><pre><code class="language-julia hljs">using Distributed
using OrdinaryDiffEq
using Plots

addprocs()
@everywhere using OrdinaryDiffEq</code></pre><p>Now let&#39;s define the linear ODE, which is our base problem:</p><pre><code class="language-julia hljs"># Linear ODE which starts at 0.5 and solves from t=0.0 to t=1.0
prob = ODEProblem((u, p, t) -&gt; 1.01u, 0.5, (0.0, 1.0))</code></pre><p>For our ensemble simulation, we would like to change the initial condition around. This is done through the <code>prob_func</code>. This function takes in the base problem and modifies it to create the new problem that the trajectory actually solves. The <code>prob_func</code> has the signature <code>prob_func(prob, i, repeat)</code> where:</p><ul><li><code>prob</code> is the base problem to be modified</li><li><code>i</code> is the unique trajectory index (<code>1</code> to <code>trajectories</code>)  </li><li><code>repeat</code> is the repeat iteration number (starts at <code>1</code>, increments if <code>output_func</code> returned <code>rerun=true</code>)</li></ul><p>Here, we will take the base problem, multiply the initial condition by a <code>rand()</code>, and use that for calculating the trajectory:</p><pre><code class="language-julia hljs">@everywhere function prob_func(prob, i, repeat)
    remake(prob, u0 = rand() * prob.u0)
end</code></pre><p>Now we build and solve the <code>EnsembleProblem</code> with this base problem and <code>prob_func</code>:</p><pre><code class="language-julia hljs">ensemble_prob = EnsembleProblem(prob, prob_func = prob_func)
sim = solve(ensemble_prob, Tsit5(), EnsembleDistributed(), trajectories = 10)</code></pre><p>We can use the plot recipe to plot what the 10 ODEs look like:</p><pre><code class="language-julia hljs">plot(sim, linealpha = 0.4)</code></pre><p>We note that if we wanted to find out what the initial condition was for a given trajectory, we can retrieve it from the solution. <code>sim[i]</code> returns the <code>i</code>th solution object. <code>sim[i].prob</code> is the problem that specific trajectory solved, and <code>sim[i].prob.u0</code> would then be the initial condition used in the <code>i</code>th trajectory.</p><p>Note: If the problem has callbacks, the functions for the <code>condition</code> and <code>affect!</code> must be named functions (not anonymous functions).</p><h3 id="Using-multithreading"><a class="docs-heading-anchor" href="#Using-multithreading">Using multithreading</a><a id="Using-multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#Using-multithreading" title="Permalink"></a></h3><p>The previous ensemble simulation can also be parallelized using a multithreading approach, which will make use of the different cores within a single computer. Because the memory is shared across the different threads, it is not necessary to use the <code>@everywhere</code> macro. Instead, the same problem can be implemented simply as:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
prob = ODEProblem((u, p, t) -&gt; 1.01u, 0.5, (0.0, 1.0))
function prob_func(prob, i, repeat)
    remake(prob, u0 = rand() * prob.u0)
end
ensemble_prob = EnsembleProblem(prob, prob_func = prob_func)
sim = solve(ensemble_prob, Tsit5(), EnsembleThreads(), trajectories = 10)
using Plots;
plot(sim);</code></pre><img src="28dbb6fd.svg" alt="Example block output"/><p>The number of threads to be used has to be defined outside of Julia, in the environmental variable <code>JULIA_NUM_THREADS</code> (see Julia&#39;s <a href="https://docs.julialang.org/en/v1.1/manual/environment-variables/#JULIA_NUM_THREADS-1">documentation</a> for details).</p><h3 id="Pre-Determined-Initial-Conditions"><a class="docs-heading-anchor" href="#Pre-Determined-Initial-Conditions">Pre-Determined Initial Conditions</a><a id="Pre-Determined-Initial-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-Determined-Initial-Conditions" title="Permalink"></a></h3><p>Often, you may already know what initial conditions you want to use. This can be specified by the <code>i</code> argument of the <code>prob_func</code>. This <code>i</code> is the unique index of each trajectory. So, if we have <code>trajectories=100</code>, then we have <code>i</code> as some index in <code>1:100</code>, and it&#39;s different for each trajectory.</p><p>So, if we wanted to use a grid of evenly spaced initial conditions from <code>0</code> to <code>1</code>, we could simply index the <code>linspace</code> type:</p><pre><code class="language-julia hljs">initial_conditions = range(0, stop = 1, length = 100)
function prob_func(prob, i, repeat)
    remake(prob, u0 = initial_conditions[i])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">prob_func (generic function with 1 method)</code></pre><p>It&#39;s worth noting that if you run this code successfully, there will be no visible output.</p><h2 id="Example-2:-Solving-an-SDE-with-Different-Parameters"><a class="docs-heading-anchor" href="#Example-2:-Solving-an-SDE-with-Different-Parameters">Example 2: Solving an SDE with Different Parameters</a><a id="Example-2:-Solving-an-SDE-with-Different-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Solving-an-SDE-with-Different-Parameters" title="Permalink"></a></h2><p>Let&#39;s solve the same SDE, but with varying parameters. Let&#39;s create a Lotka-Volterra system with multiplicative noise. Our Lotka-Volterra system will have as its drift component:</p><pre><code class="language-julia hljs">function f(du, u, p, t)
    du[1] = p[1] * u[1] - p[2] * u[1] * u[2]
    du[2] = -3 * u[2] + u[1] * u[2]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><p>For our noise function, we will use multiplicative noise:</p><pre><code class="language-julia hljs">function g(du, u, p, t)
    du[1] = p[3] * u[1]
    du[2] = p[4] * u[2]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">g (generic function with 1 method)</code></pre><p>Now we build the SDE with these functions:</p><pre><code class="language-julia hljs">using StochasticDiffEq
p = [1.5, 1.0, 0.1, 0.1]
prob = SDEProblem(f, g, [1.0, 1.0], (0.0, 10.0), p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">SDEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 10.0)
u0: 2-element Vector{Float64}:
 1.0
 1.0</code></pre><p>This is the base problem for our study. What would like to do with this experiment is keep the same parameters in the deterministic component each time, but vary the parameters for the amount of noise using <code>0.3rand(2)</code> as our parameters. Once again, we do this with a <code>prob_func</code>, and here we modify the parameters in <code>prob.p</code>:</p><pre><code class="language-julia hljs"># `p` is a global variable, referencing it would be type unstable.
# Using a let block defines a small local scope in which we can
# capture that local `p` which isn&#39;t redefined anywhere in that local scope.
# This allows it to be type stable.
prob_func = let p = p
    (prob, i, repeat) -&gt; begin
        x = 0.3rand(2)
        remake(prob, p = [p[1], p[2], x[1], x[2]])
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#2 (generic function with 1 method)</code></pre><p>Now we solve the problem 10 times and plot all of the trajectories in phase space:</p><pre><code class="language-julia hljs">ensemble_prob = EnsembleProblem(prob, prob_func = prob_func)
sim = solve(ensemble_prob, SRIW1(), trajectories = 10)
using Plots;
plot(sim, linealpha = 0.6, color = :blue, idxs = (0, 1), title = &quot;Phase Space Plot&quot;);
plot!(sim, linealpha = 0.6, color = :red, idxs = (0, 2), title = &quot;Phase Space Plot&quot;)</code></pre><img src="aac56d0e.svg" alt="Example block output"/><p>We can then summarize this information with the mean/variance bounds using a <code>EnsembleSummary</code> plot. We will take the mean/quantile at every <code>0.1</code> time units and directly plot the summary:</p><pre><code class="language-julia hljs">summ = EnsembleSummary(sim, 0:0.1:10)
plot(summ, fillalpha = 0.5)</code></pre><img src="2e3b54a9.svg" alt="Example block output"/><p>Note that here we used the quantile bounds, which default to <code>[0.05,0.95]</code> in the <code>EnsembleSummary</code> constructor. We can change to standard error of the mean bounds using <code>ci_type=:SEM</code> in the plot recipe.</p><h2 id="Example-3:-Using-the-Reduction-to-Halt-When-Estimator-is-Within-Tolerance"><a class="docs-heading-anchor" href="#Example-3:-Using-the-Reduction-to-Halt-When-Estimator-is-Within-Tolerance">Example 3: Using the Reduction to Halt When Estimator is Within Tolerance</a><a id="Example-3:-Using-the-Reduction-to-Halt-When-Estimator-is-Within-Tolerance-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Using-the-Reduction-to-Halt-When-Estimator-is-Within-Tolerance" title="Permalink"></a></h2><p>In this problem, we will solve the equation just as many times as needed to get the standard error of the mean for the final time point below our tolerance <code>0.5</code>. Since we only care about the endpoint, we can tell the <code>output_func</code> to discard the rest of the data.</p><pre><code class="language-julia hljs">function output_func(sol, i)
    last(sol), false
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">output_func (generic function with 1 method)</code></pre><p>Our <code>prob_func</code> will simply randomize the initial condition:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
# Linear ODE which starts at 0.5 and solves from t=0.0 to t=1.0
prob = ODEProblem((u, p, t) -&gt; 1.01u, 0.5, (0.0, 1.0))

function prob_func(prob, i, repeat)
    remake(prob, u0 = rand() * prob.u0)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">prob_func (generic function with 1 method)</code></pre><p>Our reduction function will append the data from the current batch to the previous batch, and declare convergence if the standard error of the mean is calculated as sufficiently small:</p><pre><code class="language-julia hljs">using Statistics
function reduction(u, batch, I)
    u = append!(u, batch)
    finished = (var(u) / sqrt(last(I))) / mean(u) &lt; 0.5
    u, finished
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">reduction (generic function with 1 method)</code></pre><p>Then we can define and solve the problem:</p><pre><code class="language-julia hljs">prob2 = EnsembleProblem(prob, prob_func = prob_func, output_func = output_func,
    reduction = reduction, u_init = Vector{Float64}())
sim = solve(prob2, Tsit5(), trajectories = 10000, batch_size = 20)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleSolution Solution of length 20 with uType:
Float64</code></pre><p>Since <code>batch_size=20</code>, this means that every 20 simulations, it will take this batch, append the results to the previous batch, calculate <code>(var(u)/sqrt(last(I)))/mean(u)</code>, and if that&#39;s small enough, exit the simulation. In this case, the simulation exits only after 20 simulations (i.e. after calculating the first batch). This can save a lot of time!</p><p>In addition to saving time by checking convergence, we can save memory by reducing between batches. For example, say we only care about the mean at the end once again. Instead of saving the solution at the end for each trajectory, we can instead save the running summation of the endpoints:</p><pre><code class="language-julia hljs">function reduction(u, batch, I)
    u + sum(batch), false
end
prob2 = EnsembleProblem(prob, prob_func = prob_func, output_func = output_func,
    reduction = reduction, u_init = 0.0)
sim2 = solve(prob2, Tsit5(), trajectories = 100, batch_size = 20)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleSolution Solution of length 1 with uType:
Float64</code></pre><p>this will sum up the endpoints after every 20 solutions, and save the running sum. The final result will have <code>sim2.u</code> as simply a number, and thus <code>sim2.u/100</code> would be the mean.</p><h2 id="Example-4:-Using-the-Analysis-Tools"><a class="docs-heading-anchor" href="#Example-4:-Using-the-Analysis-Tools">Example 4: Using the Analysis Tools</a><a id="Example-4:-Using-the-Analysis-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Using-the-Analysis-Tools" title="Permalink"></a></h2><p>In this example, we will show how to analyze a <code>EnsembleSolution</code>. First, let&#39;s generate a 10 solution Monte Carlo experiment. For our problem, we will use a <code>4x2</code> system of linear stochastic differential equations:</p><pre><code class="language-julia hljs">function f(du, u, p, t)
    for i in 1:length(u)
        du[i] = 1.01 * u[i]
    end
end
function σ(du, u, p, t)
    for i in 1:length(u)
        du[i] = 0.87 * u[i]
    end
end
using StochasticDiffEq
prob = SDEProblem(f, σ, ones(4, 2) / 2, (0.0, 1.0)) #prob_sde_2Dlinear</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">SDEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Matrix{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 1.0)
u0: 4×2 Matrix{Float64}:
 0.5  0.5
 0.5  0.5
 0.5  0.5
 0.5  0.5</code></pre><p>To solve this 10 times, we use the <code>EnsembleProblem</code> constructor and solve with <code>trajectories=10</code>. Since we wish to compare values at the timesteps, we need to make sure the steps all hit the same times. We thus set <code>adaptive=false</code> and explicitly give a <code>dt</code>.</p><pre><code class="language-julia hljs">prob2 = EnsembleProblem(prob)
sim = solve(prob2, SRIW1(), dt = 1 // 2^(3), trajectories = 10, adaptive = false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleSolution Solution of length 10 with uType:
RODESolution{Float64, 3, Vector{Matrix{Float64}}, Nothing, Nothing, Vector{Float64}, DiffEqNoiseProcess.NoiseProcess{Float64, 3, Float64, Matrix{Float64}, Matrix{Float64}, Vector{Matrix{Float64}}, typeof(DiffEqNoiseProcess.INPLACE_WHITE_NOISE_DIST), typeof(DiffEqNoiseProcess.INPLACE_WHITE_NOISE_BRIDGE), Nothing, true, ResettableStacks.ResettableStack{Tuple{Float64, Matrix{Float64}, Matrix{Float64}}, true}, ResettableStacks.ResettableStack{Tuple{Float64, Matrix{Float64}, Matrix{Float64}}, true}, DiffEqNoiseProcess.RSWM{Float64}, Nothing, Random.Xoshiro}, Nothing, SDEProblem{Matrix{Float64}, Tuple{Float64, Float64}, true, SciMLBase.NullParameters, Nothing, SDEFunction{true, SciMLBase.FullSpecialize, typeof(Main.f), typeof(Main.σ), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing}, typeof(Main.σ), Base.Pairs{Symbol, Union{}, Nothing, @NamedTuple{}}, Nothing}, StochasticDiffEq.SRIW1, StochasticDiffEq.LinearInterpolationData{Vector{Matrix{Float64}}, Vector{Float64}}, SciMLBase.DEStats, Nothing, Nothing}</code></pre><p><strong>Note that if you don&#39;t do the <code>timeseries_steps</code> calculations, this code is compatible with adaptive timestepping. Using adaptivity is usually more efficient!</strong></p><p>We can compute the mean and the variance at the 3rd timestep using:</p><pre><code class="language-julia hljs">using SciMLBase.EnsembleAnalysis
m, v = timestep_meanvar(sim, 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.6692469982104068 0.6153596985266684; 0.7171991805132676 0.6169528053433478; 0.6696591178055659 0.6393116584451095; 0.7136916515093601 0.5540492297201121], [0.06656824192558508 0.0894860087982582; 0.16840619585155606 0.03634381606857093; 0.06873764800516287 0.036449835532817276; 0.06021271211626362 0.03373967228528413])</code></pre><p>or we can compute the mean and the variance at the <code>t=0.5</code> using:</p><pre><code class="language-julia hljs">m, v = timepoint_meanvar(sim, 0.5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.8715950576749184 0.857611544261938; 1.0358364660048314 0.8076909195828873; 0.6969098443263168 0.7112370261541506; 1.104317671200015 0.8576692321435809], [0.23389512326847914 0.43284857874703997; 0.4813020363904 0.11988765169435202; 0.12897357101452758 0.06737871756649952; 0.46732539750299373 0.09267584195778773])</code></pre><p>We can get a series for the mean and the variance at each time step using:</p><pre><code class="language-julia hljs">m_series, v_series = timeseries_steps_meanvar(sim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(RecursiveArrayTools.DiffEqArray{Float64, 3, Vector{Matrix{Float64}}, Vector{Float64}, Nothing, SymbolicIndexingInterface.SymbolCache{Nothing, Nothing, Nothing, Vector{Any}, Dict{Any, Any}}, Nothing}([[0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.6117460501344042 0.5961162141215418; 0.6452368897002279 0.6387022261847857; 0.5611779692218436 0.5941309573508674; 0.6258379083591762 0.5285099171938964], [0.6692469982104068 0.6153596985266684; 0.7171991805132676 0.6169528053433478; 0.6696591178055659 0.6393116584451095; 0.7136916515093601 0.5540492297201121], [0.7049406541322619 0.7366782562017875; 0.8835521007408518 0.7702535005058339; 0.6351672463300496 0.6078880272281774; 0.8011137008408783 0.5847516083603572], [0.8715950576749184 0.857611544261938; 1.0358364660048314 0.8076909195828873; 0.6969098443263168 0.7112370261541506; 1.104317671200015 0.8576692321435809], [0.9109191289475733 0.8433942200363705; 1.2286883927968144 1.05817370942543; 0.8248218147256307 0.7523491797978463; 1.2498615333978425 0.9759435351791346], [0.9252673015513722 0.9560174800335395; 1.4980260796653293 1.1442511506917943; 1.1367665587282865 0.8393375768933944; 1.5302552111046714 1.2063025180997666], [1.026593823902176 1.048069074905516; 1.6916522402660965 1.1627851882367777; 1.0658009551987138 0.8432096946011487; 1.4998342945382108 1.4580006675967474], [0.9906074228328864 1.33527839411218; 2.0038468510813714 1.3566681240461045; 1.3938341827927847 0.9170305516127999; 1.8172167073184875 1.6524036742521573]], [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0], nothing, SymbolicIndexingInterface.SymbolCache{Nothing, Nothing, Nothing, Vector{Any}, Dict{Any, Any}}(nothing, nothing, nothing, Any[], Dict{Any, Any}()), nothing), RecursiveArrayTools.DiffEqArray{Float64, 3, Vector{Matrix{Float64}}, Vector{Float64}, Nothing, SymbolicIndexingInterface.SymbolCache{Nothing, Nothing, Nothing, Vector{Any}, Dict{Any, Any}}, Nothing}([[0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0], [0.024441969793884386 0.022033149218780954; 0.02507510998153663 0.03503119795407681; 0.04662846904078503 0.030232192391366423; 0.02127984020294289 0.022609771651152494], [0.06656824192558508 0.0894860087982582; 0.16840619585155606 0.03634381606857093; 0.06873764800516287 0.036449835532817276; 0.06021271211626362 0.03373967228528413], [0.08184500599221975 0.248816950879837; 0.4393355309690249 0.07452302254019268; 0.054201280951654274 0.014968329316987094; 0.13509617631978882 0.03877677649291981], [0.23389512326847914 0.43284857874703997; 0.4813020363904 0.11988765169435202; 0.12897357101452758 0.06737871756649952; 0.46732539750299373 0.09267584195778773], [0.18607198883528797 0.4035315951420414; 1.0957062504157826 0.22175513914628256; 0.3779249591252683 0.06946028064768459; 0.3624894867048568 0.12346244648593781], [0.24273111195786123 0.5217045464539747; 3.1832645125886616 0.27337727289392827; 1.215328884588636 0.1673816114445492; 0.8163200037345667 0.21518418558139565], [0.39854525621308323 0.9546415030302088; 5.132588836331696 0.19139716670836576; 0.9146008437248886 0.13432429531974843; 1.27315940075469 0.8003795203736697], [0.4696883026604703 1.7029832956999729; 6.674216828037843 0.3047922198518007; 1.805239968352581 0.18806697416746865; 2.506429165243025 1.3925164103060645]], [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0], nothing, SymbolicIndexingInterface.SymbolCache{Nothing, Nothing, Nothing, Vector{Any}, Dict{Any, Any}}(nothing, nothing, nothing, Any[], Dict{Any, Any}()), nothing))</code></pre><p>or at chosen values of <code>t</code>:</p><pre><code class="language-julia hljs">ts = 0:0.1:1
m_series = timeseries_point_mean(sim, ts)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">t: 0.0:0.1:1.0
u: 11-element Vector{Matrix{Float64}}:
 [0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5]
 [0.5893968401075234 0.5768929712972334; 0.6161895117601823 0.6109617809478285; 0.5489423753774748 0.5753047658806939; 0.600670326687341 0.5228079337551171]
 [0.6462466189800056 0.6076623047646177; 0.6884142641880517 0.625652573679923; 0.626266658372077 0.6212393780074128; 0.6785501542492867 0.5438335047096257]
 [0.6835244605791487 0.6638871215967159; 0.7837403486043012 0.6782730834083422; 0.6558623692153593 0.6267422059583367; 0.7486604712419672 0.5663301811762101]
 [0.7382715348407932 0.7608649138138176; 0.9140089737936476 0.7777409843212447; 0.6475157659293032 0.628557827013372; 0.8617544949127055 0.639335133117002]
 [0.8715950576749183 0.8576115442619381; 1.0358364660048311 0.8076909195828872; 0.6969098443263166 0.7112370261541507; 1.1043176712000151 0.8576692321435809]
 [0.9030543146930421 0.8462376848814841; 1.190118007438418 1.0080771514569213; 0.7992394206457678 0.7441267490691071; 1.2207527609582767 0.952288674572024]
 [0.9195280325098525 0.9109681760346717; 1.3902910049179233 1.1098201741852485; 1.0119886611272242 0.804542218055175; 1.4180977400219397 1.1141589249315138]
 [0.9657979104916935 0.9928381179823302; 1.575476543905636 1.1516647657097876; 1.1083803173164575 0.8408864239764959; 1.5180868444780875 1.3069817778985588]
 [1.019396543688318 1.105510938746849; 1.7540911624291513 1.2015617753986434; 1.1314076007175282 0.8579738660034788; 1.5633107770942662 1.4968812689278295]
 [0.9906074228328865 1.3352783941121802; 2.003846851081371 1.3566681240461045; 1.3938341827927847 0.9170305516127998; 1.8172167073184873 1.6524036742521573]</code></pre><p>Note that these mean and variance series can be directly plotted. We can compute covariance matrices similarly:</p><pre><code class="language-julia hljs">timeseries_steps_meancov(sim) # Use the time steps, assume fixed dt
timeseries_point_meancov(sim, 0:(1 // 2 ^ (3)):1, 0:(1 // 2 ^ (3)):1) # Use time points, interpolate</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9×9 Matrix{Tuple{Matrix{Float64}, Matrix{Float64}, Matrix{Float64}}}:
 ([0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0])                                          …  ([0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0])
 ([0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.611746 0.596116; 0.645237 0.638702; 0.561178 0.594131; 0.625838 0.52851], [0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0])      ([0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [0.611746 0.596116; 0.645237 0.638702; 0.561178 0.594131; 0.625838 0.52851], [0.0629563 0.0864111; 0.228887 -0.0185214; 0.0108094 -0.012748; -0.0207458 -0.0149313])
 ([0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.669247 0.61536; 0.717199 0.616953; 0.669659 0.639312; 0.713692 0.554049], [0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0])      ([0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [0.669247 0.61536; 0.717199 0.616953; 0.669659 0.639312; 0.713692 0.554049], [0.126225 0.159606; 0.532019 -0.0165166; 0.101943 0.0138903; 0.0250192 0.00903735])
 ([0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.704941 0.736678; 0.883552 0.770254; 0.635167 0.607888; 0.801114 0.584752], [0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0])     ([0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [0.704941 0.736678; 0.883552 0.770254; 0.635167 0.607888; 0.801114 0.584752], [0.150285 0.524149; 1.59766 0.082905; 0.17056 0.00541829; 0.268635 0.0139009])
 ([0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.871595 0.857612; 1.03584 0.807691; 0.69691 0.711237; 1.10432 0.857669], [0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0])        ([0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [0.871595 0.857612; 1.03584 0.807691; 0.69691 0.711237; 1.10432 0.857669], [0.250818 0.663533; 1.45429 0.0465227; 0.388934 0.0611825; 0.517819 0.114845])
 ([0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.910919 0.843394; 1.22869 1.05817; 0.824822 0.752349; 1.24986 0.975944], [0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0])     …  ([0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [0.910919 0.843394; 1.22869 1.05817; 0.824822 0.752349; 1.24986 0.975944], [0.24062 0.733616; 2.51854 0.0617768; 0.72948 0.0535399; 0.622613 0.23092])
 ([0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.925267 0.956017; 1.49803 1.14425; 1.13677 0.839338; 1.53026 1.2063], [0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0])           ([0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [0.925267 0.956017; 1.49803 1.14425; 1.13677 0.839338; 1.53026 1.2063], [0.224218 0.805386; 4.38362 0.171075; 1.45065 0.130808; 1.22658 0.349811])
 ([0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [1.02659 1.04807; 1.69165 1.16279; 1.0658 0.84321; 1.49983 1.458], [0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0])                ([0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [1.02659 1.04807; 1.69165 1.16279; 1.0658 0.84321; 1.49983 1.458], [0.391616 1.22993; 5.78168 0.168332; 1.27176 0.13761; 1.67403 0.940627])
 ([0.5 0.5; 0.5 0.5; 0.5 0.5; 0.5 0.5], [0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [0.0 0.0; 0.0 0.0; 0.0 0.0; 0.0 0.0])            ([0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [0.990607 1.33528; 2.00385 1.35667; 1.39383 0.917031; 1.81722 1.6524], [0.469688 1.70298; 6.67422 0.304792; 1.80524 0.188067; 2.50643 1.39252])</code></pre><p>For general analysis, we can build a <code>EnsembleSummary</code> type.</p><pre><code class="language-julia hljs">summ = EnsembleSummary(sim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleSolution Solution of length 9 with uType:
Float64</code></pre><p>will summarize at each time step, while</p><pre><code class="language-julia hljs">summ = EnsembleSummary(sim, 0.0:0.1:1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleSolution Solution of length 11 with uType:
Float64</code></pre><p>will summarize at the <code>0.1</code> time points using the interpolations. To visualize the results, we can plot it. Since there are 8 components to the differential equation, this can get messy, so let&#39;s only plot the 3rd component:</p><pre><code class="language-julia hljs">using Plots;
plot(summ; idxs = 3);</code></pre><img src="3b319859.svg" alt="Example block output"/><p>We can change to errorbars instead of ribbons and plot two different indices:</p><pre><code class="language-julia hljs">plot(summ; idxs = (3, 5), error_style = :bars)</code></pre><img src="f185443a.svg" alt="Example block output"/><p>Or we can simply plot the mean of every component over time:</p><pre><code class="language-julia hljs">plot(summ; error_style = :none)</code></pre><img src="d6b8a0f4.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Init_Solve/">« The SciML init and solve Functions</a><a class="docs-footer-nextpage" href="../Common_Keywords/">Common Keyword Arguments »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 22 December 2025 10:41">Monday 22 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
